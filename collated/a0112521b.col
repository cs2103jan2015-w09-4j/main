//@author: a0112521b



	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\data\Data.java
	 */

/**
 * The Data class contains two types of data which is AliasData and TaskData
 */
public class Data {

    private AliasData alias;
    private TaskData task;

    /**
     * Default constructor of Data
     */
    public Data() {
        this.task = new TaskData();
        this.alias = new AliasData();
    }

    /**
     * @return the alias
     */
    public AliasData getAlias() {
        return this.alias;
    }

    /**
     * @return the task
     */
    public TaskData getTask() {
        return this.task;
    }

    /**
     * @param alias
     *            the alias to set
     */
    public void setAlias(AliasData alias) {
        this.alias = alias;
    }

    /**
     * @param task
     *            the task to set
     */
    public void setTask(TaskData task) {
        this.task = task;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\data\Data.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\Config.java
	 */

/**
 * Class encapsulates configuration options for program. This includes whether
 * program is running in CLI or GUI mode, where to read/dump data to/from etc.
 */
public class Config implements IStorableElement {

    private DatabaseConfig database;
    private DisplayConfig display;
    private ParserConfig parser;
    private TaskManagerConfig taskManager;
    private TerminalConfig terminal;

    /**
     *
     */
    public Config() {
        this.database = new DatabaseConfig();
        this.display = new DisplayConfig();
        this.parser = new ParserConfig();
        this.taskManager = new TaskManagerConfig();
        this.terminal = new TerminalConfig();
    }

    /**
     * @return the database
     */
    public DatabaseConfig getDatabase() {
        return this.database;
    }

    /**
     * @return the display
     */
    public DisplayConfig getDisplay() {
        return this.display;
    }

    /**
     * @return the parser
     */
    public ParserConfig getParser() {
        return this.parser;
    }

    /**
     * @return the taskManager
     */
    public TaskManagerConfig getTaskManager() {
        return this.taskManager;
    }

    /**
     * @return the terminal
     */
    public TerminalConfig getTerminal() {
        return this.terminal;
    }

    @Override
    public boolean isValid() {
        return this.database.isValid() && this.display.isValid()
                && this.parser.isValid() && this.taskManager.isValid()
                && this.terminal.isValid();
    }

    /**
     * @param database
     *            the database to set
     */
    public void setDatabase(DatabaseConfig database) {
        this.database = database;
    }

    /**
     * @param display
     *            the display to set
     */
    public void setDisplay(DisplayConfig display) {
        this.display = display;
    }

    /**
     * @param parser
     *            the parser to set
     */
    public void setParser(ParserConfig parser) {
        this.parser = parser;
    }

    /**
     * @param taskManager
     *            the taskManager to set
     */
    public void setTaskManager(TaskManagerConfig taskManager) {
        this.taskManager = taskManager;
    }

    /**
     * @param terminal
     *            the terminal to set
     */
    public void setTerminal(TerminalConfig terminal) {
        this.terminal = terminal;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\Config.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DatabaseConfig.java
	 */

package w094j.ctrl8.database.config;

import w094j.ctrl8.database.IStorableElement;

/**
 * Configuration file for Database.
 */
public class DatabaseConfig implements IStorableElement {
    private DiskStorageConfig diskStorage;
    private GoogleStorageConfig googleStorage;

    /**
     * Creates a Database config with empty diskStorage and googleStorage
     * configs.
     */
    public DatabaseConfig() {
        this.diskStorage = new DiskStorageConfig();
        this.googleStorage = new GoogleStorageConfig();
    }

    /**
     * @return the diskStorageConfig
     */
    public DiskStorageConfig getDiskStorageConfig() {
        return this.diskStorage;
    }

    /**
     * @return the googleStorageConfig
     */
    public GoogleStorageConfig getGoogleStorageConfig() {
        return this.googleStorage;
    }

    @Override
    public boolean isValid() {
        return this.diskStorage.isValid()
                && this.googleStorage.isValid();
    }

    /**
     * @param diskStorageConfig
     *            the command to set
     */
    public void setDiskStorageConfig(DiskStorageConfig diskStorageConfig) {
        this.diskStorage = diskStorageConfig;
    }

    /**
     * @param googleStorageConfig
     *            the googleStorageConfig to set
     */
    public void setGoogleStorageConfig(GoogleStorageConfig googleStorageConfig) {
        this.googleStorage = googleStorageConfig;
    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DatabaseConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DiskStorageConfig.java
	 */

/**
 * Configuration file for DiskStorage.
 */
public class DiskStorageConfig implements IStorableElement {

    /**
     * Frequency of the clearing of the history.
     */
    @SuppressWarnings("javadoc")
    public enum Frequency {
        DAILY, MONTHLY, SESSION, WEEKLY, YEARLY
    }

    private static Frequency AUTO_CLEAR_HISTORY_FREQUENCY_DEFAULT = Frequency.SESSION;
    private Frequency autoClearHistoryFrequency;

    /**
     *
     */
    public DiskStorageConfig() {
    }

    /**
     * Gets how frequent the history will be cleared
     *
     * @return Frequency
     */
    public Frequency getAutoClearHistoryFrequency() {
        if (this.autoClearHistoryFrequency == null) {
            return AUTO_CLEAR_HISTORY_FREQUENCY_DEFAULT;
        } else {
            return this.autoClearHistoryFrequency;
        }
    }

    @Override
    public boolean isValid() {
        return true;
    }

    /**
     * Sets how frequent the history will be cleared. Possible values are:
     * Frequency.SESSION, Frequency.DAILY, Frequency.WEEKLY, Frequency.MONTHLY,
     * Frequency.YEARLY
     *
     * @param frequency
     */
    public void setAutoClearHistoryFrequency(Frequency frequency) {
        this.autoClearHistoryFrequency = frequency;
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DiskStorageConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GoogleStorageConfig.java
	 */

package w094j.ctrl8.database.config;

import w094j.ctrl8.database.IStorableElement;

/**
 * Configuration file for GoogleStorage.
 */
public class GoogleStorageConfig implements IStorableElement {

    private static Boolean AUTO_DOWNLOAD_AFTER_SAVE_DEFAULT = true;
    private static Boolean SYNC_WITH_GOOGLE_DEFAULT = true;
    private Boolean autoDownloadAfterSave;
    private Boolean syncWithGoogle;

    /**
     * Creates a GoogleStorage Config object
     */
    public GoogleStorageConfig() {
    }

    /**
     * @return autoDownloadAfterSave
     */
    public Boolean getAutoDownloadAfterSave() {
        if (this.autoDownloadAfterSave == null) {
            return AUTO_DOWNLOAD_AFTER_SAVE_DEFAULT;
        } else {
            return this.autoDownloadAfterSave;
        }
    }

    /**
     * @return syncWithGoogle
     */
    public Boolean getSyncWithGoogle() {
        if (this.syncWithGoogle == null) {
            return SYNC_WITH_GOOGLE_DEFAULT;
        } else {
            return this.syncWithGoogle;
        }
    }

    @Override
    public boolean isValid() {
        if (!this.syncWithGoogle && this.autoDownloadAfterSave) {
            return false;
        }
        return true;
    }

    /**
     * @param autoSyncAfterSave
     */
    public void setAutoSync(Boolean autoSyncAfterSave) {
        this.autoDownloadAfterSave = autoSyncAfterSave;
    }

    /**
     * @param syncWithGoogle
     */
    public void setSyncWithGoogle(Boolean syncWithGoogle) {
        this.syncWithGoogle = syncWithGoogle;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GoogleStorageConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\Database.java
	 */


public class Database implements IDatabase {

    private static final String DEFAULT_FILE_NAME = "Ctrl-8.txt";
    private static final String FILE_FORMAT = ".txt";
    private static Database instance;

    private DBfile file;
    private Gson gson;
    private Path path;

    /**
     * @param pathString
     * @throws IOException
     * @throws NoSuchFileException
     */
    public Database(String pathString) throws IOException, NoSuchFileException {
        GsonBuilder builder = new GsonBuilder();
        builder.registerTypeAdapter(Statement.class, new StatementGsonAdaptor());
        builder.enableComplexMapKeySerialization();
        this.gson = builder.setPrettyPrinting().create();
        this.path = this.getOrCreatePath(pathString);
        this.file = this.path.toFile().isFile() ? this.getFile() : new DBfile();
    }

    /**
     * Gets the current instance of the CLIDisplay.
     *
     * @return the current instance.
     */
    public static Database getInstance() {
        if (instance == null) {
            throw new RuntimeException(
                    "Database must be initialized before retrieveing.");
        }
        return instance;
    }

    /**
     * @param filePath
     * @return instance
     * @throws NoSuchFileException
     * @throws IOException
     */
    public static Database initInstance(String filePath)
            throws NoSuchFileException, IOException {

        if (instance != null) {
            throw new RuntimeException(
                    "Cannot initialize Database as it was initialized before.");
        } else {
            instance = new Database(filePath);
        }
        return instance;

    }

    @Override
    public void downloadFromStorage() throws GeneralSecurityException,
    IOException, DataException {
        Storage diskStorage = new DiskStorage(this.file, this.path, this.gson);
        Storage googleCalStorage = new GoogleStorage(this.file, this.gson);
        diskStorage.readData();
        googleCalStorage.readData();
    }

    /**
     * @return config
     */
    @Override
    public Config getConfig() {
        return this.file.getConfig();
    }

    @Override
    public Data getData() {
        return this.file.getData();
    }

    /**
     * Save and write file.
     *
     * @throws IOException
     * @throws GeneralSecurityException
     * @throws DataException
     */
    @Override
    public void saveToStorage() throws GeneralSecurityException, IOException,
    DataException {
        Storage googleStorage = new GoogleStorage(this.file, this.gson);
        googleStorage.storeData();
        Storage diskStorage = new DiskStorage(this.file, this.path, this.gson);
        diskStorage.storeData();
    }

    @Override
    public void sync() {

    }

    private DBfile getFile() throws IOException {
        String json = new String(Files.readAllBytes(this.path));
        return this.gson.fromJson(json, DBfile.class);
    }

    private Path getOrCreatePath(String directory) throws IOException {
        if ((directory == null) || directory.equals("")) {
            return new File(DEFAULT_FILE_NAME).toPath();
        }

        String filename = DEFAULT_FILE_NAME;
        if (directory.endsWith(FILE_FORMAT)) {
            if (!directory.contains(File.separator)) {
                filename = directory;
                directory = "";
            } else {
                filename = directory.substring(directory
                        .lastIndexOf(File.separator));
                directory = directory.substring(0,
                        directory.lastIndexOf(File.separator));
            }
        }
        new FileDataStoreFactory(new java.io.File(directory));
        return new File(directory + filename).toPath();
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\Database.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\DiskStorage.java
	 */

package w094j.ctrl8.database;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import w094j.ctrl8.pojo.DBfile;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

/**
 * Disk Storage
 */
public class DiskStorage extends Storage {

    DBfile file;
    Path filePath;
    private Gson gson;

    /**
     * @param file
     * @param filePath
     * @param gson
     */
    public DiskStorage(DBfile file, Path filePath, Gson gson) {
        super(file);
        this.file = file;
        this.filePath = filePath;
        this.gson = gson;
    }

    @Override
    public void readData() throws IOException {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        String json = new String(Files.readAllBytes(this.filePath));
        this.file = gson.fromJson(json, DBfile.class);
    }

    @Override
    public void storeData() {
        String json = this.gson.toJson(this.file);
        try {
            Files.write(this.filePath, json.getBytes());
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

    @Override
    public void sync() {
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\DiskStorage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\Factory.java
	 */

package w094j.ctrl8.database;

import java.io.IOException;

import w094j.ctrl8.database.config.Config;
import w094j.ctrl8.display.Display;
import w094j.ctrl8.parse.Parser;
import w094j.ctrl8.taskmanager.TaskManager;
import w094j.ctrl8.terminal.Terminal;

/**
 * Factory This class will initialize all instance of Database, Config, Parser,
 * Display, TaskManager and Terminal.
 */
public class Factory {

    private static Factory instance;

    /**
     * @param filePath
     * @throws IOException
     */
    private Factory(String filePath) throws IOException {
        Database db = null;
        try {
            db = Database.initInstance(filePath);
        } catch (Exception e) {
            System.out
            .println("Database corrupted, delete config file and retry.");
        }
        Config config = db.getConfig();

        Parser parser = Parser.initInstance(config.getParser(), db.getData()
                .getAlias());
        Display display = Display.initInstance(config.getDisplay());
        TaskManager taskManager = TaskManager.initInstance(config
                .getTaskManager(), db.getData().getAlias(), db.getData()
                .getTask());
        Terminal.initInstance(config.getTerminal(), taskManager, display,
                parser, db);
    }

    /**
     * Return the instance of this Factory class
     *
     * @return instance
     * @throws IOException
     */
    public static Factory getInstance() throws IOException {
        if (instance == null) {
            throw new RuntimeException(
                    "Cannot initialize when it was initialized.");
        }
        return instance;
    }

    /**
     * Initialize the instance of Factory class and return the instance
     *
     * @param filePath
     * @return instance
     * @throws IOException
     */

    public static Factory initInstance(String filePath) throws IOException {
        if (instance != null) {
            throw new RuntimeException(
                    "Cannot initialize when it was initialized.");
        } else {
            instance = new Factory(filePath);
        }
        return instance;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\Factory.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\GoogleStorage.java
	 */

package w094j.ctrl8.database;

import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;

import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import w094j.ctrl8.database.config.GoogleStorageConfig;
import w094j.ctrl8.exception.DataException;
import w094j.ctrl8.message.NormalMessage;
import w094j.ctrl8.parse.statement.CommandType;
import w094j.ctrl8.pojo.Actions;
import w094j.ctrl8.pojo.DBfile;
import w094j.ctrl8.pojo.Task;
import w094j.ctrl8.pojo.Task.TaskType;

import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.googleapis.json.GoogleJsonResponseException;
import com.google.api.client.http.HttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.client.util.DateTime;
import com.google.api.client.util.store.DataStore;
import com.google.api.client.util.store.FileDataStoreFactory;
import com.google.api.services.calendar.CalendarScopes;
import com.google.api.services.calendar.model.Calendar;
import com.google.api.services.calendar.model.Event;
import com.google.api.services.calendar.model.Event.Reminders;
import com.google.api.services.calendar.model.EventDateTime;
import com.google.api.services.calendar.model.EventReminder;
import com.google.api.services.tasks.TasksScopes;
import com.google.api.services.tasks.model.TaskList;
import com.google.api.services.tasks.model.Tasks;
import com.google.gson.Gson;

/**
 * Google Calendar Storage
 */
public class GoogleStorage extends Storage {
    private static DataStore<ObjectId> dataStoreEvent;
    private static FileDataStoreFactory dataStoreFactory;
    private static DataStore<String> dataStoreSyncSettings;
    private static DataStore<ObjectId> dataStoreTask;
    private static final String EMPTY_STRING = "";
    private static final String ERROR_MESSAGE_FILE_NOT_FOUND = " file not found";
    private static final int FULL_SYNC_YEAR_FROM_NOW = -1;
    private static final String GOOGLE_EVENT_STATUS_CANCELLED = "cancelled";
    private static final String GOOGLE_EVENT_STATUS_CONFIRMED = "confirmed";
    private static final String GOOGLE_TASK_STATUS_COMPLETED = "completed";
    private static final String GOOGLE_TASK_STATUS_NEEDS_ACTION = "needsAction";
    private static HttpTransport httpTransport;
    private static JsonFactory jsonFactory = new JacksonFactory();
    private static Logger logger = LoggerFactory.getLogger(GoogleStorage.class);
    private static final int MILLISECONDS_IN_A_MINUTE = 60000;
    private static final String NO_TITLE = "(No title)";
    private static final String SYNC_TOKEN_KEY = "syncToken";
    private com.google.api.services.calendar.Calendar.Events.List calendarRequest;
    private final String CLIENT_SECRETS_FILE = "/client_secrets.json";
    private com.google.api.services.calendar.Calendar clientCalendar;
    private GoogleClientSecrets clientSecrets;
    private com.google.api.services.tasks.Tasks clientTask;
    private GoogleStorageConfig config;
    private Credential credential;
    private final java.io.File DATA_STORE_CALENDAR_INFO_FILE = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME
            + "/CalendarInfo");
    private final java.io.File DATA_STORE_CREDENTIAL_FILE = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME
            + "/StoredCredential");
    private final java.io.File DATA_STORE_DIR = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME);
    private final java.io.File DATA_STORE_EVENT_STORE = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME
            + "/EventStore");
    private final java.io.File DATA_STORE_INETERNET_STATUS_LAST_SESSION = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME
            + "/InternetStatusLastSession");
    private final java.io.File DATA_STORE_SYNC_SETTINGS = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME
            + "/SyncSettings");
    private final java.io.File DATA_STORE_TASK_STORE = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME
            + "/TaskStore");
    private final java.io.File DATA_STORE_TASKLIST_INFO_FILE = new java.io.File(
            System.getProperty("user.home"), ".store/" + NormalMessage.APP_NAME
            + "/TaskListInfo");
    private DBfile dbFile;
    private final String EVENT_REMINDER_METHOD_EMAIL = "email";
    private final String EVENT_REMINDER_METHOD_POPUP = "popup";
    private final String EVENT_STORE = "EventStore";
    private com.google.api.services.calendar.model.Events events;
    private final String GOOGLE_WEBSITE = "www.google.com";
    private Calendar googleCalendar;
    private TaskList googleTaskList;
    private Gson gson;
    private boolean isAutoDownloadAfterSave;
    private boolean isInternetReachableLastSession;
    private boolean isSyncWithGoogle;
    private final String SYNC_SETTINGS = "SyncSettings";
    private final String TASK_STORE = "TaskStore";
    private ArrayList<String> toBeDeletedGoogleEventIdList;
    private ArrayList<String> toBeDeletedGoogleTaskIdList;
    private final String userId = "user";

    /**
     * @param file
     * @param gson
     * @throws IOException
     * @throws GeneralSecurityException
     */
    public GoogleStorage(DBfile file, Gson gson)
            throws GeneralSecurityException, IOException {
        super(file);
        this.dbFile = file;
        this.gson = gson;
        this.setConfig();
        this.initialize();
    }

    @Override
    public void readData() throws IOException, DataException {
        if (this.isSyncWithGoogle && this.isInternetReachable()) {
            this.getUnsyncedEventsAndTasksFromGoogle();
        }
    }

    @Override
    public void storeData() throws IOException, DataException {
        if (this.isSyncWithGoogle) {
            boolean isInternetReachableThisSession = this.isInternetReachable();

            if (isInternetReachableThisSession) {
                if (this.isInternetReachableLastSession) {
                    this.updateOneUnsyncedEventOrTaskToGoogle();
                } else {
                    this.updateAllUnsyncedEventsAndTasksToGoogle();
                }
                if (this.isAutoDownloadAfterSave) {
                    this.getUnsyncedEventsAndTasksFromGoogle();
                }
            }

            this.saveIntenetStatusInfo();

        }
    }

    @Override
    public void sync() throws IOException, DataException {
        if (this.isSyncWithGoogle && this.isInternetReachable()) {
            this.updateAllUnsyncedEventsAndTasksToGoogle();
            this.getUnsyncedEventsAndTasksFromGoogle();
        }
    }

    private void addGoogleEvent(Task localEvent) throws IOException {
        logger.info("Adding event: " + localEvent.getTitle());
        Event googleEvent = new Event();

        this.setGoogleEventFields(googleEvent, localEvent);
        googleEvent.setStatus(GOOGLE_EVENT_STATUS_CONFIRMED);

        // insert event
        googleEvent = this.clientCalendar.events()
                .insert(this.googleCalendar.getId(), googleEvent).execute();

        // set google id and etag
        localEvent.setGoogleId(googleEvent.getId());
        localEvent.setEtag(googleEvent.getEtag());

        dataStoreEvent.set(googleEvent.getId(), localEvent.getId());
    }

    private void addGoogleTask(Task localTask) throws IOException {
        logger.info("Adding task: " + localTask.getTitle());
        com.google.api.services.tasks.model.Task googleTask = new com.google.api.services.tasks.model.Task();

        this.setGoogleTaskFields(googleTask, localTask);
        googleTask.setDeleted(false);

        // insert task
        googleTask = this.clientTask.tasks()
                .insert(this.googleTaskList.getId(), googleTask).execute();

        // set google id and etag
        localTask.setGoogleId(googleTask.getId());
        localTask.setEtag(googleTask.getEtag());

        dataStoreTask.set(googleTask.getId(), localTask.getId());
    }

    private void addLocalEvent(Event googleEvent) throws DataException,
    IOException {
        logger.info("Adding new event from Google: " + googleEvent.getSummary());
        Task localEvent = new Task();
        localEvent.setGoogleId(googleEvent.getId());
        this.setLocalEventFields(googleEvent, localEvent);
        dataStoreEvent.set(googleEvent.getId(), localEvent.getId());

        this.dbFile.getData().getTask().updateTaskMap(localEvent, null, false);
    }

    private void addLocalTask(
            com.google.api.services.tasks.model.Task googleTask)
                    throws IOException, DataException {
        logger.info("Adding new task from Google: " + googleTask.getTitle());
        Task localTask = new Task();
        localTask.setGoogleId(googleTask.getId());
        this.setLocalTaskFields(googleTask, localTask);
        dataStoreTask.set(googleTask.getId(), localTask.getId());

        this.dbFile.getData().getTask().updateTaskMap(localTask, null, false);
    }

    private void addToGoogle(Task localTask) throws IOException {
        if (localTask.getTaskType() == TaskType.TIMED) {
            this.addGoogleEvent(localTask);
        } else {
            this.addGoogleTask(localTask);
        }
    }

    private void createCalendar() throws IOException {
        logger.info("Adding a new calendar...");
        Calendar entry = new Calendar();
        entry.setSummary(NormalMessage.APP_NAME);
        this.googleCalendar = this.clientCalendar.calendars().insert(entry)
                .execute();
    }

    private void createOrGetCalendar() throws IOException {
        if (this.DATA_STORE_CALENDAR_INFO_FILE.exists()) {
            this.getCalendarInfo();
        } else {
            this.createCalendar();
            this.saveCalendarInfo();
        }
    }

    private void createOrGetIntenetStatusLastSession() throws IOException {
        if (this.DATA_STORE_INETERNET_STATUS_LAST_SESSION.exists()) {
            this.getInternetStatusLastSession();
        } else {
            this.saveIntenetStatusInfo();
        }
    }

    private void createOrGetTaskList() throws IOException {
        if (this.DATA_STORE_TASKLIST_INFO_FILE.exists()) {
            this.getTaskListInfo();
        } else {
            this.createTaskList();
            this.saveTaskListInfo();
        }
    }

    private void createTaskList() throws IOException {
        logger.info("Adding a new task list...");
        TaskList entry = new TaskList();
        entry.setTitle(NormalMessage.APP_NAME);
        this.googleTaskList = this.clientTask.tasklists().insert(entry)
                .execute();
    }

    private void deleteFile(File file) {
        try {
            if (file.delete()) {
                logger.info("Deleted " + file);
            } else {
                logger.debug("Failed to delete " + file);
            }
        } catch (Exception e) {
            logger.debug("Failed to delete " + file);
            e.printStackTrace();
        }

    }

    @SuppressWarnings("unchecked")
    private void deleteFromGoogle() throws IOException {
        logger.info("Deleting Google Event/Task...");
        List<Task> localTaskList = Arrays.asList(this.dbFile.getData()
                .getTask().getTaskList());
        ArrayList<String> tempGoogleTaskIdList = (ArrayList<String>) this.toBeDeletedGoogleTaskIdList
                .clone();
        ArrayList<String> tempGoogleEventIdList = (ArrayList<String>) this.toBeDeletedGoogleEventIdList
                .clone();

        for (Task i : localTaskList) {
            tempGoogleTaskIdList.remove(i.getGoogleId());
            tempGoogleEventIdList.remove(i.getGoogleId());
        }

        for (String googleId : tempGoogleTaskIdList) {
            this.deleteGoogleTask(googleId);
        }

        for (String googleId : tempGoogleEventIdList) {
            this.deleteGoogleEvent(googleId);
        }
    }

    private void deleteGoogleEvent(String googleId) throws IOException {
        logger.info("Deleting Google Event: " + googleId);
        dataStoreEvent.delete(googleId);
        try {
            this.clientCalendar.events()
            .delete(this.googleCalendar.getId(), googleId).execute();
        } catch (IOException e) {
            logger.info("Fail to delete Google Event: " + googleId);
        }
    }

    private void deleteGoogleTask(String googleId) throws IOException {
        logger.info("Deleting Google Task: " + googleId);
        dataStoreTask.delete(googleId);
        try {
            this.clientTask.tasks()
            .delete(this.googleTaskList.getId(), googleId).execute();
        } catch (IOException e) {
            logger.info("Fail to delete Google Task: " + googleId);
        }
    }

    private void deleteLocalGoogleInfo() {
        this.deleteFile(this.DATA_STORE_CALENDAR_INFO_FILE);
        this.deleteFile(this.DATA_STORE_CREDENTIAL_FILE);
        this.deleteFile(this.DATA_STORE_EVENT_STORE);
        this.deleteFile(this.DATA_STORE_INETERNET_STATUS_LAST_SESSION);
        this.deleteFile(this.DATA_STORE_SYNC_SETTINGS);
        this.deleteFile(this.DATA_STORE_TASK_STORE);
        this.deleteFile(this.DATA_STORE_TASKLIST_INFO_FILE);
        this.deleteFile(this.DATA_STORE_DIR);
    }

    private void deleteLocalTask(Task localTask) throws IOException {
        if (localTask != null) {
            logger.info("Deleting local task/event: " + localTask.getTitle());
            if (localTask.getTaskType() == TaskType.TIMED) {
                dataStoreEvent.delete(localTask.getGoogleId());
            } else {
                dataStoreTask.delete(localTask.getGoogleId());
            }
            this.dbFile.getData().getTask().getTaskStateMap()
            .get(localTask.getId()).setFinalTask(null);
        }
    }

    private void getCalendarInfo() throws IOException {
        logger.info("Getting user's calendar info...");
        String json = new String(
                Files.readAllBytes(this.DATA_STORE_CALENDAR_INFO_FILE.toPath()));
        this.googleCalendar = new Calendar();
        this.googleCalendar = this.gson.fromJson(json, Calendar.class);
    }

    private void getClientSecrets() {
        try {
            logger.info("Getting client secrets...");
            this.clientSecrets = GoogleClientSecrets.load(
                    jsonFactory,
                    new InputStreamReader(GoogleStorage.class
                            .getResourceAsStream(this.CLIENT_SECRETS_FILE)));
        } catch (Exception e) {
            logger.debug(this.CLIENT_SECRETS_FILE
                    + ERROR_MESSAGE_FILE_NOT_FOUND);
            System.err.println(this.CLIENT_SECRETS_FILE
                    + ERROR_MESSAGE_FILE_NOT_FOUND);
            System.exit(1);
        }
    }

    private void getDataStoreInfo() throws IOException {
        dataStoreEvent = dataStoreFactory.getDataStore(this.EVENT_STORE);
        dataStoreTask = dataStoreFactory.getDataStore(this.TASK_STORE);
        dataStoreSyncSettings = dataStoreFactory
                .getDataStore(this.SYNC_SETTINGS);
    }

    private java.util.Date getGoogleCalendarStartSyncDate() {
        java.util.Calendar cal = java.util.Calendar.getInstance();
        cal.setTime(new java.util.Date());
        cal.add(java.util.Calendar.YEAR, FULL_SYNC_YEAR_FROM_NOW);
        return cal.getTime();
    }

    private void getInternetStatusLastSession() throws IOException {
        logger.info("Getting Internet status last session...");
        String json = new String(
                Files.readAllBytes(this.DATA_STORE_INETERNET_STATUS_LAST_SESSION
                        .toPath()));
        this.isInternetReachableLastSession = this.gson.fromJson(json,
                Boolean.class);
    }

    private Task getLocalEventByGoogleId(String googleId) {

        ObjectId taskId = null;
        try {
            if (dataStoreEvent.get(googleId) != null) {
                taskId = dataStoreEvent.get(googleId);
            }
        } catch (IOException e) {
            return null;
        }
        if (taskId != null) {
            return this.dbFile.getData().getTask().getTask(taskId);
        }
        return null;

    }

    private Task getLocalTaskByGoogleId(String googleId) {

        ObjectId taskId = null;
        try {
            if (dataStoreTask.get(googleId) != null) {
                taskId = dataStoreTask.get(googleId);
            }

        } catch (IOException e) {
            return null;
        }
        if (taskId != null) {
            return this.dbFile.getData().getTask().getTask(taskId);
        }
        return null;

    }

    private void getTaskListInfo() throws IOException {
        logger.info("Getting user's tasklist info...");
        String json = new String(
                Files.readAllBytes(this.DATA_STORE_TASKLIST_INFO_FILE.toPath()));
        this.googleTaskList = this.gson.fromJson(json, TaskList.class);
    }

    private void getTempGoogleIdList() throws IOException {
        this.toBeDeletedGoogleEventIdList = new ArrayList<String>(
                dataStoreEvent.keySet());
        this.toBeDeletedGoogleTaskIdList = new ArrayList<String>(
                dataStoreTask.keySet());
    }

    private void getUnsyncedEventsAndTasksFromGoogle() throws IOException,
            DataException {
        this.syncGoogleCalendar();
        this.syncGoogleTaskList();
    }

    private void initialize() throws GeneralSecurityException, IOException {
        if (this.isSyncWithGoogle) {
            if (this.isInternetReachable()) {
                this.initializeTransport();
                this.initializeDataStoreFactory();
                this.getClientSecrets();
                this.setUpAuthorizationCodeFlow();
                this.setUpGlobalCaleandarInstance();
                this.setUpGlobalTaskInstance();
                this.createOrGetCalendar();
                this.createOrGetTaskList();
                this.createOrGetIntenetStatusLastSession();
                this.getDataStoreInfo();
                this.getTempGoogleIdList();
            }
        } else if (this.DATA_STORE_DIR.exists()) {
            this.deleteLocalGoogleInfo();
            this.removeUnnecessaryInfoForLocalTasks();
        }
    }

    private void initializeDataStoreFactory() throws IOException {
        logger.info("Initializing DataStoreFactory...");
        dataStoreFactory = new FileDataStoreFactory(this.DATA_STORE_DIR);
    }

    private void initializeTransport() throws GeneralSecurityException,
    IOException {
        logger.info("Initializing Transport...");
        httpTransport = GoogleNetHttpTransport.newTrustedTransport();
    }

    private boolean isInternetReachable() {
        try {
            InetAddress google = InetAddress.getByName(this.GOOGLE_WEBSITE);
            try {
                google.isReachable(0);
                logger.info("Has internet connection");
            } catch (IOException e) {
                logger.info("No internet connection");
                return false;
            }
        } catch (UnknownHostException e) {
            logger.info("No internet connection");
            return false;
        }
        return true;
    }

    @SuppressWarnings("unused")
    private boolean isValidGoogleEventId(String googleId) {
        try {
            this.clientCalendar.events()
            .get(this.googleCalendar.getId(), googleId).execute();
            logger.info("Valid Google Event ID: " + googleId);
            return true;
        } catch (IOException e) {
            logger.info("Invalid Google Event ID: " + googleId);
            return false;
        }
    }

    @SuppressWarnings("unused")
    private boolean isValidGoogleTaskId(String googleId) {
        try {
            this.clientTask.tasks().get(this.googleTaskList.getId(), googleId)
            .execute();
            logger.info("Valid Google Task ID: " + googleId);
            return true;
        } catch (IOException e) {
            logger.info("Invalid Google Task ID: " + googleId);
            return false;
        }
    }

    private void loadSyncToken() throws IOException {
        logger.info("Loading Sync Token...");
        String syncToken = dataStoreSyncSettings.get(SYNC_TOKEN_KEY);

        if (syncToken == null) {
            this.calendarRequest.setTimeMin(new DateTime(this
                    .getGoogleCalendarStartSyncDate(), TimeZone.getDefault()));
        } else {
            this.calendarRequest.setSyncToken(syncToken);
        }
    }

    private void markAsDoneInGoogle(Task localTask) throws IOException {
        if (localTask.getTaskType() == TaskType.TIMED) {
            Event googleEvent = this.clientCalendar.events()
                    .get(this.googleCalendar.getId(), localTask.getGoogleId())
                    .execute();
            try {
                this.syncEvent(localTask, googleEvent);
            } catch (Exception e) {
                e.printStackTrace();
            }

        } else {
            com.google.api.services.tasks.model.Task googleTask = this.clientTask
                    .tasks()
                    .get(this.googleTaskList.getId(), localTask.getGoogleId())
                    .execute();
            try {
                this.syncTask(localTask, googleTask);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private void modifyInGoogle(Task localTask) throws IOException,
    DataException {
        if (localTask.getTaskType() == TaskType.TIMED) {
            if (dataStoreEvent.containsKey(localTask.getGoogleId())) {
                // modify event
                Event googleEvent = this.clientCalendar
                        .events()
                        .get(this.googleCalendar.getId(),
                                localTask.getGoogleId()).execute();
                try {
                    this.syncEvent(localTask, googleEvent);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else {
                // change task -> event
                if (dataStoreTask.containsKey(localTask.getGoogleId())) {
                    this.deleteGoogleTask(localTask.getGoogleId());
                }
                this.addGoogleEvent(localTask);
            }
        } else {
            if (dataStoreTask.containsKey(localTask.getGoogleId())) {
                // modify task
                com.google.api.services.tasks.model.Task googleTask = this.clientTask
                        .tasks()
                        .get(this.googleTaskList.getId(),
                                localTask.getGoogleId()).execute();
                this.syncTask(localTask, googleTask);
            } else {
                // change event -> task
                if (dataStoreEvent.containsKey(localTask.getGoogleId())) {
                    this.deleteGoogleEvent(localTask.getGoogleId());
                }
                this.addGoogleTask(localTask);
            }
        }

    }

    private void removeUnnecessaryInfoForLocalTasks() {
        List<Task> localTaskList = Arrays.asList(this.dbFile.getData()
                .getTask().getTaskList());

        for (Task i : localTaskList) {
            i.setGoogleId(null);
            i.setEtag(null);
            i.setSyncStatus(null);
        }
    }

    private void saveCalendarInfo() {
        logger.info("Saving calendar info to "
                + this.DATA_STORE_CALENDAR_INFO_FILE);
        String json = this.gson.toJson(this.googleCalendar);
        try {
            Files.write(this.DATA_STORE_CALENDAR_INFO_FILE.toPath(),
                    json.getBytes());
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

    private void saveIntenetStatusInfo() throws IOException {
        logger.info("Saving Internet Status info to "
                + this.DATA_STORE_INETERNET_STATUS_LAST_SESSION);
        String json = this.gson.toJson(this.isInternetReachable());
        try {
            Files.write(this.DATA_STORE_INETERNET_STATUS_LAST_SESSION.toPath(),
                    json.getBytes());
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

    private void saveTaskListInfo() {
        logger.info("Saving tasklist info to "
                + this.DATA_STORE_TASKLIST_INFO_FILE);
        this.googleTaskList.setUpdated(null);
        String json = this.gson.toJson(this.googleTaskList);
        try {
            Files.write(this.DATA_STORE_TASKLIST_INFO_FILE.toPath(),
                    json.getBytes());
        } catch (IOException e1) {
            e1.printStackTrace();
        }

    }

    private void setConfig() {
        this.config = this.dbFile.getConfig().getDatabase()
                .getGoogleStorageConfig();
        this.isAutoDownloadAfterSave = this.config.getAutoDownloadAfterSave();
        this.isSyncWithGoogle = this.config.getSyncWithGoogle();
    }

    private void setGoogleEventFields(Event googleEvent, Task localEvent) {
        DateTime dateTime;

        // set title/summary
        googleEvent.setSummary(localEvent.getTitle());

        // set start date
        dateTime = new DateTime(localEvent.getStartDate(),
                TimeZone.getDefault());
        googleEvent.setStart(new EventDateTime().setDateTime(dateTime));

        // set end date
        dateTime = new DateTime(localEvent.getEndDate(), TimeZone.getDefault());
        googleEvent.setEnd(new EventDateTime().setDateTime(dateTime));

        // set description
        googleEvent.setDescription(localEvent.getDescription());

        // set location
        googleEvent.setLocation(localEvent.getLocation());

        // set reminder
        if (localEvent.getReminder() != null) {
            EventReminder eventReminderEmail = new EventReminder();
            eventReminderEmail.setMethod(this.EVENT_REMINDER_METHOD_EMAIL);
            eventReminderEmail.setMinutes((int) (localEvent.getStartDate()
                    .getTime() - localEvent.getReminder().getTime())
                    / MILLISECONDS_IN_A_MINUTE);

            EventReminder eventReminderPopUp = new EventReminder();
            eventReminderPopUp.setMethod(this.EVENT_REMINDER_METHOD_POPUP);
            eventReminderPopUp.setMinutes((int) (localEvent.getStartDate()
                    .getTime() - localEvent.getReminder().getTime())
                    / MILLISECONDS_IN_A_MINUTE);

            List<EventReminder> eventReminderList = new ArrayList<EventReminder>();
            eventReminderList.add(eventReminderEmail);
            eventReminderList.add(eventReminderPopUp);

            Reminders reminders = new Reminders();
            reminders.setUseDefault(false);
            reminders.setOverrides(eventReminderList);

            googleEvent.setReminders(reminders);
        } else {
            googleEvent.setReminders(null);
        }

    }

    private void setGoogleTaskFields(
            com.google.api.services.tasks.model.Task googleTask, Task localTask) {
        // set title
        googleTask.setTitle(localTask.getTitle());

        // set status
        if (localTask.getStatus()) {
            googleTask.setStatus(GOOGLE_TASK_STATUS_COMPLETED);
        } else {
            googleTask.setStatus(GOOGLE_TASK_STATUS_NEEDS_ACTION);
        }

        // set description/note
        googleTask.setNotes(localTask.getDescription());

        // set end date/due date
        if (localTask.getEndDate() != null) {
            DateTime dateTime = new DateTime(localTask.getEndDate(),
                    TimeZone.getDefault());
            googleTask.setDue(dateTime);
        } else {
            googleTask.setDue(null);
        }
    }

    private void setLocalEventFields(Event googleEvent, Task localEvent)
            throws DataException {

        java.util.Calendar cal = java.util.Calendar.getInstance();

        if (googleEvent.getSummary() != null) {
            localEvent.setTitle(googleEvent.getSummary());
        } else {
            localEvent.setTitle(NO_TITLE);
        }

        if (googleEvent.getDescription() != null) {
            localEvent.setDescription(googleEvent.getDescription());
        }

        if (googleEvent.getStart().getDate() == null) {
            localEvent.setStartDate(new Date(googleEvent.getStart()
                    .getDateTime().getValue()));
        } else {
            localEvent.setStartDate(new Date(googleEvent.getStart().getDate()
                    .getValue()));
        }

        if (googleEvent.getEnd().getDate() == null) {
            localEvent.setEndDate(new Date(googleEvent.getEnd().getDateTime()
                    .getValue()));
        } else {
            localEvent.setEndDate(new Date(googleEvent.getEnd().getDate()
                    .getValue()));
        }

        if (googleEvent.getLocation() != null) {
            localEvent.setLocation(googleEvent.getLocation());
        }

        if (googleEvent.getReminders().getUseDefault()
                || (googleEvent.getReminders().getOverrides() == null)) {
            localEvent.setReminder(null);
        } else {
            int minutesBeforeStartDate = googleEvent.getReminders()
                    .getOverrides().get(0).getMinutes();
            cal.setTime(localEvent.getStartDate());
            cal.add(java.util.Calendar.MINUTE, (-1) * minutesBeforeStartDate);
            localEvent.setReminder(cal.getTime());
        }
        localEvent.toCompleteTask();
        localEvent.setEtag(googleEvent.getEtag());
    }

    private void setLocalTaskFields(
            com.google.api.services.tasks.model.Task googleTask, Task localTask)
                    throws DataException {
        if ((googleTask.getTitle() == null)
                || googleTask.getTitle().equals(EMPTY_STRING)) {
            localTask.setTitle(NO_TITLE);
        } else {
            localTask.setTitle(googleTask.getTitle());
        }
        localTask.setDescription(googleTask.getNotes());
        if (googleTask.getDue() != null) {
            localTask.setEndDate(new Date(googleTask.getDue().getValue()));
        }
        if ((googleTask.getStatus() != null)
                && googleTask.getStatus().equals(GOOGLE_TASK_STATUS_COMPLETED)) {
            localTask.setStatus(true);
        } else {
            localTask.setStatus(false);
        }
        localTask.toCompleteTask();
        localTask.setEtag(googleTask.getEtag());
    }

    private void setNextSyncToken() throws IOException {
        logger.info("Setting next sync token...");
        dataStoreSyncSettings.set(SYNC_TOKEN_KEY,
                this.events.getNextSyncToken());
    }

    private void setUpAuthorizationCodeFlow() throws IOException {
        logger.info("Setting up authorization code flow...");
        GoogleAuthorizationCodeFlow flow;

        flow = new GoogleAuthorizationCodeFlow.Builder(httpTransport,
                jsonFactory, this.clientSecrets,
                Collections.singleton(CalendarScopes.CALENDAR + " "
                        + TasksScopes.TASKS)).setDataStoreFactory(
                                dataStoreFactory).build();
        this.credential = new AuthorizationCodeInstalledApp(flow,
                new LocalServerReceiver()).authorize(this.userId);

    }

    private void setUpGlobalCaleandarInstance() {
        logger.info("Setting up global caleandar instance...");
        this.clientCalendar = new com.google.api.services.calendar.Calendar.Builder(
                httpTransport, jsonFactory, this.credential)
        .setApplicationName(NormalMessage.APP_NAME).build();

    }

    private void setUpGlobalTaskInstance() {
        logger.info("Setting up global task instance...");
        this.clientTask = new com.google.api.services.tasks.Tasks.Builder(
                httpTransport, jsonFactory, this.credential)
        .setApplicationName(NormalMessage.APP_NAME).build();
    }

    private void syncAllEvents() throws IOException, DataException {
        logger.info("Syncing all events...");
        String pageToken = null;
        this.events = null;
        do {
            this.calendarRequest.setPageToken(pageToken);

            try {
                this.events = this.calendarRequest.execute();
            } catch (GoogleJsonResponseException e) {
                if (e.getStatusCode() == 410) {
                    logger.info("Invalid sync token, clearing event store and re-syncing...");
                    dataStoreSyncSettings.delete(SYNC_TOKEN_KEY);
                    dataStoreEvent.clear();
                    this.syncGoogleCalendar();
                } else {
                    throw e;
                }
            }

            List<Event> items = this.events.getItems();
            if (items.size() == 0) {
                logger.info("No new events to sync.");
            } else {
                for (Event event : items) {
                    this.syncEventFromGoogle(event);
                }
            }

            pageToken = this.events.getNextPageToken();
        } while (pageToken != null);
    }

    private void syncEvent(Task localEvent, Event googleEvent)
            throws IOException, DataException {
        logger.info("Updating Google event: " + localEvent.getTitle());

        Date googleEventLastModifiedTime = new Date(googleEvent.getUpdated()
                .getValue());

        if (localEvent.getLastModifiedTime()
                .before(googleEventLastModifiedTime)) {
            this.updateLocalEvent(googleEvent, localEvent);
        } else {
            this.updateGoogleEvent(googleEvent, localEvent);
        }
    }

    private void syncEventFromGoogle(Event googleEvent) throws IOException,
    DataException {
        Task localEvent = this.getLocalEventByGoogleId(googleEvent.getId());

        if (GOOGLE_EVENT_STATUS_CANCELLED.equals(googleEvent.getStatus())) {
            if (dataStoreEvent.containsKey(googleEvent.getId())) {
                if (localEvent != null) {
                    this.deleteLocalTask(localEvent);
                }
            }
        } else {
            if (localEvent != null) {
                this.syncEvent(localEvent, googleEvent);
            } else {
                this.addLocalEvent(googleEvent);
            }
        }
    }

    private void syncGoogleCalendar() throws IOException, DataException {
        logger.info("Syncing Google Calendar...");
        this.calendarRequest = this.clientCalendar.events().list(
                this.googleCalendar.getId());
        this.loadSyncToken();
        this.syncAllEvents();
        this.setNextSyncToken();
    }

    private void syncGoogleTaskList() throws IOException, DataException {
        logger.info("Syncing Google Task List...");
        Tasks tasks = this.clientTask.tasks().list(this.googleTaskList.getId())
                .execute();

        if (tasks.getItems() != null) {
            List<com.google.api.services.tasks.model.Task> items = tasks
                    .getItems();
            logger.info("Google Task List size: " + items.size());

            for (com.google.api.services.tasks.model.Task googleTask : items) {
                Task localTask = this
                        .getLocalTaskByGoogleId(googleTask.getId());

                if ((localTask == null)) {
                    this.addLocalTask(googleTask);
                    this.toBeDeletedGoogleTaskIdList.remove(googleTask.getId());
                } else {
                    this.syncTask(localTask, googleTask);
                    this.toBeDeletedGoogleTaskIdList.remove(googleTask.getId());
                }
            }
        }

        for (String googleId : this.toBeDeletedGoogleTaskIdList) {
            this.deleteLocalTask(this.getLocalTaskByGoogleId(googleId));
        }
    }

    private void syncTask(Task localTask,
            com.google.api.services.tasks.model.Task googleTask)
                    throws IOException, DataException {

        Date googleTaskLastModifiedTime = new Date(googleTask.getUpdated()
                .getValue());

        if (!localTask.getIsSynced()) {
            if (!localTask.getEtag().equals(googleTask.getEtag())) {
                // both local and google tasks changed, overwrite the latest one
                if (localTask.getLastModifiedTime().after(
                        googleTaskLastModifiedTime)) {
                    this.updateGoogleTask(googleTask, localTask);
                } else {
                    if (googleTask.getDeleted() == null) {
                        this.updateLocalTask(googleTask, localTask);
                    } else {
                        // google task flagged as deleted
                        this.deleteLocalTask(localTask);
                    }
                }
            } else {
                // only local task changed
                this.updateGoogleTask(googleTask, localTask);
            }
        } else {
            if (!localTask.getEtag().equals(googleTask.getEtag())) {
                // only google task changed
                this.updateGoogleTask(googleTask, localTask);
            }
        }
    }

    private void updateAllUnsyncedEventsAndTasksToGoogle() throws IOException,
            DataException {
        logger.info("Uploading unsynced Events and Tasks");
        List<Task> localTaskList = Arrays.asList(this.dbFile.getData()
                .getTask().getTaskList());

        for (Task i : localTaskList) {
            if ((i.getIsSynced() == null)) {
                this.addToGoogle(i);
            } else if (!i.getIsSynced()) {
                this.modifyInGoogle(i);
                this.toBeDeletedGoogleTaskIdList.remove(i.getGoogleId());
                this.toBeDeletedGoogleEventIdList.remove(i.getGoogleId());
            } else if (i.getIsSynced()) {
                this.toBeDeletedGoogleTaskIdList.remove(i.getGoogleId());
                this.toBeDeletedGoogleEventIdList.remove(i.getGoogleId());
            }
        }

        for (String googleId : this.toBeDeletedGoogleTaskIdList) {
            this.deleteGoogleTask(googleId);
        }

        for (String googleId : this.toBeDeletedGoogleEventIdList) {
            this.deleteGoogleEvent(googleId);
        }

    }

    private void updateGoogleEvent(Event googleEvent, Task localEvent)
            throws IOException {
        this.setGoogleEventFields(googleEvent, localEvent);
        googleEvent.setStatus(null);
        logger.info("Updating Google event: " + localEvent.getTitle());

        googleEvent = this.clientCalendar
                .events()
                .update(this.googleCalendar.getId(), localEvent.getGoogleId(),
                        googleEvent).execute();

        localEvent.setEtag(googleEvent.getEtag());
        this.toBeDeletedGoogleEventIdList.remove(googleEvent.getId());
    }

    private void updateGoogleTask(
            com.google.api.services.tasks.model.Task googleTask, Task localTask)
                    throws IOException {
        logger.info("Updating Google task: " + localTask.getTitle());
        this.setGoogleTaskFields(googleTask, localTask);
        googleTask.setDeleted(null);
        googleTask = this.clientTask
                .tasks()
                .update(this.googleTaskList.getId().toString(),
                        localTask.getId().toString(), googleTask).execute();

        localTask.setEtag(googleTask.getEtag());
        this.toBeDeletedGoogleTaskIdList.remove(googleTask.getId());
    }

    private void updateLocalEvent(Event googleEvent, Task localEvent)
            throws DataException {
        logger.info("Updating local event: " + googleEvent.getSummary());
        this.setLocalEventFields(googleEvent, localEvent);
        this.toBeDeletedGoogleEventIdList.remove(googleEvent.getId());
    }

    private void updateLocalTask(
            com.google.api.services.tasks.model.Task googleTask, Task localTask)
                    throws DataException {
        logger.info("Updating local task: " + googleTask.getTitle());
        this.setLocalTaskFields(googleTask, localTask);
        this.toBeDeletedGoogleTaskIdList.remove(googleTask.getId());
    }

    private void updateOneUnsyncedEventOrTaskToGoogle() throws IOException,
            DataException {
        ArrayList<Actions> actionList = this.dbFile.getData().getTask()
                .getActionsList();
        if ((actionList.size() - 1) > 0) {
            Actions lastAction = actionList.get(actionList.size() - 1);
            CommandType command = lastAction.getStatement().getCommand();
            ObjectId taskId = lastAction.getTaskID();
            Task localTask = this.dbFile.getData().getTask().getTaskStateMap()
                    .get(taskId).getFinalTask();

            switch (command) {
                case ADD :
                    this.addToGoogle(localTask);
                    break;
                case DELETE :
                    this.deleteFromGoogle();
                    break;
                case DONE :
                    this.markAsDoneInGoogle(localTask);
                    break;
                case MODIFY :
                    this.modifyInGoogle(localTask);
                    break;
                default :
                    break;
            }
        }
    }
}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\GoogleStorage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\IDatabase.java
	 */

package w094j.ctrl8.database;

import java.io.IOException;
import java.security.GeneralSecurityException;

import w094j.ctrl8.data.Data;
import w094j.ctrl8.database.config.Config;
import w094j.ctrl8.exception.DataException;

/**
 * Interface for Database
 */
public interface IDatabase {

    /**
     * Download data from Disk and Google
     *
     * @throws IOException
     * @throws Exception
     */
    void downloadFromStorage() throws IOException, Exception;

    /**
     * @return Config
     */
    Config getConfig();

    /**
     * @return List<Task> from the database
     */
    Data getData();

    /**
     * Store data to Disk and Google
     *
     * @throws DataException
     *             when the task is errornous.
     * @throws IOException
     *             when the connection to Google has issues or when the internet
     *             has issues.
     * @throws GeneralSecurityException
     *             when there is file permission issues.
     */
    void saveToStorage() throws GeneralSecurityException, IOException,
            DataException;

    /**
     * Sync with Google Calendar and Google Task
     *
     * @throws Exception
     */
    void sync() throws Exception;

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\IDatabase.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\Storage.java
	 */

package w094j.ctrl8.database;

import java.io.IOException;

import w094j.ctrl8.exception.DataException;
import w094j.ctrl8.pojo.DBfile;

/**
 * Storage
 */
public abstract class Storage {
    /**
     * @param file
     */
    public Storage(DBfile file) {
    }

    /**
     * Read Data from Disk and Google
     *
     * @throws IOException
     * @throws DataException
     */
    abstract public void readData() throws IOException, DataException;

    /**
     * Store Data to Disk and Google
     *
     * @throws IOException
     * @throws DataException
     */
    abstract public void storeData() throws IOException, DataException;

    /**
     * Sync with Google
     * 
     * @throws DataException
     * @throws IOException
     */
    abstract public void sync() throws IOException, DataException;
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\Storage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\ErrorMessage.java
	 */

public class ErrorMessage {
    public static final String ERROR = "Error: ";
    public static final String ERROR_READING_INPUT = "Error: User Input Failed!";
    public static final String OPTION_NOT_FOUND = "Error: Option can't be found";
    public static final String STATEMENT_ADD_PARAMETER = "Add statement must have parameters.";
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\ErrorMessage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\HelpMessage.java
	 */


public class HelpMessage {
    //@formatter:off    
    public static final int ADD_START_INDEX = 1;
    public static final int ADD_END_INDEX = 8;
    public static final int DONE_INDEX = 9;
    public static final int DELETE_INDEX = 10;
    public static final int VIEW_INDEX = 11;
    public static final int SEARCH_INDEX = 12;
    public static final int MODIFY_INDEX = 13;
    public static final int HISTORY_INDEX = 15;
    public static final int HISTORY_CLEAR_INDEX = 16;
    public static final int HISTORY_UNDO_INDEX = 17;
    public static final int ALIAS_INDEX = 19;
    public static final int ALIAS_ADD_INDEX = 20;
    public static final int ALIAS_DELETE_INDEX = 21;
    public static final int EXIT_INDEX = 26;
 
    public static final String[][] TABLE = {
        { "Topic", "Command", "Example" },
        { "Add a New Task   (title)", "add ={<title>}", "add ={UROP Meeting}" },
        { "                 (category)", "#{<category>}", "#{school}" },
        { "                 (description)", "+{<description>}","+{Remember to talk about Crawler technologies.}" },
        { "                 (start date)", "-{<date>}", "-{today 1pm}" },
        { "                 (end date)", "~{<date>}", "~{today 3pm}" },
        { "                 (location)", "@{<location>}", "@{Prof. Martin Henz Office}" },
        { "                 (priority)", "%{<priority number(0~10)>}", "%{10}" },
        { "                 (reminder)", "!{<date>}", "!{today 12pm}" },
        { "Mark a Task as Done", "done <title>", "done UROP Meeting" },
        { "Delete a Task", "delete <title>", "delete UROP Meeting" },
        { "View All Tasks", "view", "-" },
        { "Search for a Task", "search <title>", "search UROP Meeting" },
        { "Modify a Task", "modify <title> <changes>","modify UROP Meeting @{UTown Seminar Room 8}" },
        { "", "", "" },
        { "View History Actions", "history", "-" },
        { "Clear a History Action", "history-clear <number>", "history-clear 2" },
        { "Undo a History Action", "history-undo <number>","history-undo 1" },
        { "", "", "" },
        { "View All Alias", "alias", "-" },
        { "Add a New Alias", "alias-add <alias> <phrase>", "alias-add nus National University of Singapore" },
        { "Delete an Alias", "alias-delete <alias>", "alias-delete nus" },
        { "", "", "" },
        { "Help - View All Commands", "help", "-" },
        { "Help - View a Specific Command", "help <command>", "help add" },
        { "", "", "" },
        { "Exit the Program", "exit", "-" } };    
    //@formatter:on
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\HelpMessage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AliasAddStatement.java
	 */

/**
 *
 */
public class AliasAddStatement extends Statement {

    private static Logger logger = LoggerFactory
            .getLogger(AliasAddStatement.class);

    private String alias;
    private String phrase;

    /**
     * @param statementString
     * @throws ParseException
     */
    public AliasAddStatement(String statementString) throws ParseException {
        super(CommandType.ALIAS_ADD, statementString);
        if (this.getStatementArgumentsOnly().trim().split("\\s+").length < 2) {
            throw new ParseException(
                    "AliasAdd statement must specify an alias and its phrase.");
        } else {
            String arr[] = this.getStatementArgumentsOnly().trim()
                    .split(" ", 2);
            this.alias = arr[0];
            this.phrase = arr[1];
            logger.debug("Valid alias-add Command, query \"" + statementString
                    + "\"");
        }

    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo) {
        // Statement to be added
        return taskManager.aliasAdd(this.alias, this.phrase, this, isUndo);

    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AliasAddStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AliasDeleteStatement.java
	 */

public class AliasDeleteStatement extends StatementQuery {

    private static Logger logger = LoggerFactory.getLogger(DoneStatement.class);
    private String query;

    /**
     * @param statementString
     */
    public AliasDeleteStatement(String statementString) {
        super(CommandType.ALIAS_DELETE, statementString);
        this.query = this.getStatementArgumentsOnly().trim();
        logger.debug("Valid alias-delete Command, query \"" + statementString
                + "\"");
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws DataException {
        // TODO Link to Terminal
        return taskManager.aliasDelete(this.query, this, isUndo);

    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AliasDeleteStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\DeleteStatement.java
	 */

public class DeleteStatement extends StatementQuery {

    private static Logger logger = LoggerFactory
            .getLogger(DeleteStatement.class);
    private String query;

    /**
     * @param statementString
     */
    public DeleteStatement(String statementString) {
        super(CommandType.DELETE, statementString);
        this.query = this.getStatementArgumentsOnly().trim();
        logger.debug("Valid delete Command, query \"" + statementString + "\"");
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws CommandExecuteException, DataException {

        return taskManager.delete(this.query, this, isUndo);
    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\DeleteStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\DoneStatement.java
	 */

public class DoneStatement extends StatementQuery {

    private static Logger logger = LoggerFactory.getLogger(DoneStatement.class);
    private String query;

    /**
     * @param statementString
     */
    public DoneStatement(String statementString) {
        super(CommandType.DONE, statementString);
        this.query = this.getStatementArgumentsOnly().trim();
        logger.debug("Valid done Command, query \"" + statementString + "\"");
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws CommandExecuteException, DataException {
        // TODO Link to Terminal
        // statement to be added
        return taskManager.done(this.query, this, isUndo);

    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\DoneStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HelpStatement.java
	 */

/**
 */
public class HelpStatement extends Statement {
    private static Logger logger = LoggerFactory.getLogger(HelpStatement.class);

    private CommandType command;

    /**
     * @param statementString
     */
    public HelpStatement(String statementString) {
        super(CommandType.HELP, statementString);
        CommandParser commandParser = Parser.getInstance().getStatementParser()
                .getCommandParser();
        try {

            this.command = commandParser.parse(this.getStatementArgumentsOnly()
                    .trim());
            logger.info("Help Command=" + this.command);
        } catch (ParseException e) {
            this.command = CommandType.HELP;
        }
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo) {
        return taskManager.help(this.command, this);
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HelpStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HistoryClearStatement.java
	 */

public class HistoryClearStatement extends StatementOnePosInt {

    private static Logger logger = LoggerFactory
            .getLogger(HistoryClearStatement.class);
    private String query;

    /**
     * @param statementString
     */
    public HistoryClearStatement(String statementString) {
        super(CommandType.HISTORY_CLEAR, statementString);
        this.query = this.getStatementArgumentsOnly();
        logger.debug("Valid history-clear Command, query \"" + statementString
                + "\"");
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo) {
        return taskManager.historyClear(Integer.parseInt(this.query), this);
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HistoryClearStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HistoryUndoStatement.java
	 */

public class HistoryUndoStatement extends StatementOnePosInt {

    private static Logger logger = LoggerFactory
            .getLogger(HistoryUndoStatement.class);

    /**
     * @param statementString
     */
    public HistoryUndoStatement(String statementString) {
        super(CommandType.HISTORY_UNDO, statementString);
        logger.debug("Valid history-undo Command, query \"" + statementString
                + "\"");
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws CommandExecuteException, DataException {
        // TODO Link to Terminal
        // temporary index to be passed before search implemented.
        return taskManager.historyUndo(this.getPositiveInteger(), this);
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HistoryUndoStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\StatementOnePosInt.java
	 */

/**
 * Abstract Class to encapsulate a statement which has only 1 positive integer
 * parameter.
 */
public abstract class StatementOnePosInt extends Statement {

    private int positiveInteger;

    /**
     * Creates a Statement with parameter. If the parameter is not a positive
     * integer, fail immediately.
     *
     * @param command
     *            Command type.
     * @param statementString
     *            The statement that the user entered into the terminal.
     */
    protected StatementOnePosInt(CommandType command, String statementString) {
        super(command, statementString);

        try {
            this.positiveInteger = Integer.parseInt(this
                    .getStatementArgumentsOnly());
        } catch (Exception e) {
            throw new InvalidParameterException(command
                    + " takes in 1 positive integer parameter only.");
        }

        if (this.positiveInteger < 1) {
            throw new InvalidParameterException(command
                    + " takes in 1 positive integer parameter only.");
        }

    }

    /**
     * @return the positiveInteger
     */
    public int getPositiveInteger() {
        return this.positiveInteger;
    }

    /**
     * @param positiveInteger
     *            the positiveInteger to set
     */
    public void setPositiveInteger(int positiveInteger) {
        this.positiveInteger = positiveInteger;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\StatementOnePosInt.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\StatementQuery.java
	 */

/**
 * Abstract Class to encapsulate a statement which has parameters.
 */
public abstract class StatementQuery extends Statement {

    /**
     * Creates a Statement with parameter, checks the statementString for any
     * parameters. If there are no parameters, fail immediately.
     *
     * @param command
     *            Command type.
     * @param statementString
     *            The statement that the user entered into the terminal.
     */
    protected StatementQuery(CommandType command, String statementString) {
        super(command, statementString);
        if (this.getStatementArgumentsOnly().isEmpty()) {
            throw new InvalidParameterException(command
                    + " does not have any parameters.");
        }
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\StatementQuery.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\ViewStatement.java
	 */

public class ViewStatement extends StatementNoParams {

    /**
     * Creates a new view Statement.
     *
     * @param statementString
     */
    public ViewStatement(String statementString) {
        super(CommandType.VIEW, statementString);
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws CommandExecuteException {
        return taskManager.view(this);
    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\ViewStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\DBfile.java
	 */


/**
 * TODO
 */
public class DBfile {

    private Config config;
    private Data data;

    /**
     * TODO
     */
    public DBfile() {
        this.config = new Config();
        this.data = new Data();
    }

    /**
     * TODO
     *
     * @param data
     * @param config
     */
    public DBfile(Data data, Config config) {
        this.config = config;
        this.data = new Data();
    }

    /**
     * @return the config
     */
    public Config getConfig() {
        return this.config;
    }

    /**
     * @return the data
     */
    public Data getData() {
        return this.data;
    }

    /**
     * @param config
     *            the config to set
     */
    public void setConfig(Config config) {
        this.config = config;
    }

    /**
     * @param data
     *            the data to set
     */
    public void setData(Data data) {
        this.data = data;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\DBfile.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\Task.java
	 */


public class Task implements Comparable<Task> {

    /**
     * Enumerates the current list of task types.
     */
    public enum TaskType {
        /**
         * Tasks with deadline, either with date only or date with time. Tasks
         * with only date deadline is assumed to expire at 23:59 hrs.
         */
        DEADLINE,
        /**
         * Tasks with no dateline at all.
         */
        FLOATING,
        /**
         * Tasks with no title. This is for update purpose.
         */
        INCOMPLETE,
        /**
         * Tasks with a start time and end time. Also known as events.
         */
        TIMED
    }

    private String category;
    private String description;
    private Date endDate;
    private String etag;
    private String googleId;
    //@formatter:off
    private ObjectId id;
    private Boolean isDone;

    private Boolean isSynced;

    private Date lastModifiedTime;
    private String location;
    private Integer priority;
    private Date reminder;
    private Date startDate;
    private TaskType taskType;
    //@formatter:on
    private String title;

    /**
     * default constructor
     */
    public Task() {
        this.taskType = TaskType.INCOMPLETE;
        this.id = new ObjectId();
    }

    public Task(Task task) {
        this.category = task.category;
        this.description = task.description;
        this.endDate = task.endDate == null ? null : (Date) task.endDate
                .clone();
        this.etag = task.etag;
        this.googleId = task.googleId;
        // Cloned task will share same ID object
        this.id = task.id;
        this.isDone = task.isDone;
        this.isSynced = task.isSynced;
        this.lastModifiedTime = task.lastModifiedTime == null ? null
                : (Date) task.lastModifiedTime.clone();
        this.location = task.location;
        this.priority = task.priority;
        this.reminder = task.reminder == null ? null : (Date) task.reminder
                .clone();
        this.startDate = task.startDate == null ? null : (Date) task.startDate
                .clone();
        this.taskType = task.taskType;
        this.title = task.title;
    }

    @Override
    public int compareTo(final Task task) {
        return this.title.compareTo(task.getTitle());
    }

    /**
     * @return category
     */
    public String getCategory() {
        return this.category;
    }

    /**
     * @return description
     */
    public String getDescription() {
        return this.description;
    }

    /**
     * @return end date
     */
    public Date getEndDate() {
        return this.endDate;
    }

    /**
     * @return eTag
     */
    public String getEtag() {
        return this.etag;
    }

    /**
     * @return googleId
     */
    public String getGoogleId() {
        return this.googleId;
    }

    /**
     * @return the id
     */
    public ObjectId getId() {
        return this.id;
    }

    /**
     * @return true is task is synced with Google
     */
    public Boolean getIsSynced() {
        return this.isSynced;
    }

    /**
     * @return lastModifiedTime
     */
    public Date getLastModifiedTime() {
        return this.lastModifiedTime;
    }

    /**
     * @return location
     */
    public String getLocation() {
        return this.location;
    }

    /**
     * @return priority
     */
    public Integer getPriority() {
        return this.priority;
    }

    /**
     * @return date of the reminder
     */
    public Date getReminder() {
        return this.reminder;
    }

    /**
     * @return Date :the start Date of the task
     */
    public Date getStartDate() {
        return this.startDate;
    }

    /**
     * @return status
     */
    public Boolean getStatus() {
        if (this.isDone == null) {
            return false;
        }
        return this.isDone;
    }

    /**
     * @return task type
     */
    public TaskType getTaskType() {
        this.changeTaskType();
        return this.taskType;
    }

    /**
     * @return title
     */
    public String getTitle() {
        return this.title;
    }

    /**
     * @param category
     *            the category to set
     */
    public void setCategory(String category) {
        this.category = category;
        this.updateTimeAndSyncStatus();
    }

    /**
     * @param description
     *            the description to set
     */
    public void setDescription(String description) {
        this.description = description;
        this.updateTimeAndSyncStatus();
    }

    /**
     * @param endDate
     *            the endDate to set
     */
    public void setEndDate(Date endDate) {
        this.endDate = endDate;
        this.updateTimeAndSyncStatus();
    }

    /**
     * Set eTag for Google Calendar and Google Task
     *
     * @param eTag
     */
    public void setEtag(String eTag) {
        this.etag = eTag;
        this.isSynced = true;
        this.lastModifiedTime = new Date();
    }

    /**
     * Set googleId
     *
     * @param googleId
     */
    public void setGoogleId(String googleId) {
        this.googleId = googleId;
    }

    /**
     * @param id
     *            the id to set
     */
    public void setId(ObjectId id) {
        this.id = id;
    }

    /**
     * @param location
     *            the location to set
     */
    public void setLocation(String location) {
        this.location = location;
        this.updateTimeAndSyncStatus();
    }

    /**
     * @param priority
     *            the priority to set
     */
    public void setPriority(Integer priority) {
        this.priority = priority;
        this.updateTimeAndSyncStatus();
    }

    /**
     * @param reminder
     *            the reminder to set
     */
    public void setReminder(Date reminder) {
        this.reminder = reminder;
        this.updateTimeAndSyncStatus();
    }

    /**
     * @param startDate
     *            the startDate to set
     */
    public void setStartDate(Date startDate) {
        this.startDate = startDate;
        this.updateTimeAndSyncStatus();
    }

    /**
     * @param isDone
     *            the isDone to set
     */
    public void setStatus(boolean isDone) {
        this.isDone = isDone;
        this.updateTimeAndSyncStatus();
    }

    /**
     * @param isSynced
     *            the isSynced to set
     */
    public void setSyncStatus(Boolean isSynced) {
        this.isSynced = isSynced;
    }

    /**
     * @param title
     *            the title to set
     */
    public void setTitle(String title) {
        this.title = title;
        this.updateTimeAndSyncStatus();
    }

    /**
     * Change incomplete task to complete task this.task should have a title
     * 
     * @throws DataException
     */
    public void toCompleteTask() throws DataException {

        if ((this.title == null) || this.title.equals("")) {
            throw new DataException("No title");
        }

        if ((this.location != null) && this.location.equals("")) {
            this.location = null;
        }

        if ((this.startDate != null) && (this.endDate != null)) {
            if (this.startDate.after(this.endDate)) {
                throw new DataException(
                        "Start Date shouldn't be after End Date");
            }
        }

        if ((this.category != null) && this.category.equals("")) {
            this.category = null;
        }

        if ((this.description != null) && this.description.equals("")) {
            this.description = null;
        }

        this.changeTaskType();
        this.updateTimeAndSyncStatus();
    }

    /**
     * Updates the current task and changes it to a complete task. this.task
     * should not be an incomplete task.
     *
     * @param incompleteTask
     * @return true if it updates successfully
     */
    public boolean update(Task incompleteTask) {
        if (this.taskType != TaskType.INCOMPLETE) {

            if (incompleteTask.title != null) {
                if (incompleteTask.title == "") {
                    this.title = null;
                } else {
                    this.title = incompleteTask.title;
                }
            }

            if (incompleteTask.location != null) {
                if (incompleteTask.location == "") {
                    this.location = null;
                } else {
                    this.location = incompleteTask.location;
                }
            }

            if (incompleteTask.startDate != null) {
                this.startDate = incompleteTask.startDate;
            }

            if (incompleteTask.endDate != null) {
                this.endDate = incompleteTask.endDate;
            }

            if (incompleteTask.category != null) {
                if (incompleteTask.category == "") {
                    this.category = null;
                } else {
                    this.category = incompleteTask.category;
                }
            }

            if (incompleteTask.description != null) {
                if (incompleteTask.description == "") {
                    this.description = null;
                } else {
                    this.description = incompleteTask.description;
                }
            }

            if (incompleteTask.reminder != null) {
                this.reminder = incompleteTask.reminder;
            }

            if (incompleteTask.priority != null) {
                this.priority = incompleteTask.priority;
            }

            if (incompleteTask.isDone != null) {
                this.isDone = incompleteTask.isDone;
            }

            this.changeTaskType();
            this.updateTimeAndSyncStatus();

            return true;
        } else {
            return false;
        }
    }

    /**
     * Change Task Type (incomplete/deadline/floating/timed)
     */
    private void changeTaskType() {
        if ((this.startDate == null) && (this.endDate == null)) {
            this.taskType = TaskType.FLOATING;
        } else if ((this.startDate == null) && (this.endDate != null)) {
            this.taskType = TaskType.DEADLINE;
        } else if ((this.startDate != null) && (this.endDate == null)) {
            this.endDate = this.startDate;
            this.startDate = null;
            this.taskType = TaskType.DEADLINE;
        } else {
            this.taskType = TaskType.TIMED;
        }
    }

    private void updateTimeAndSyncStatus() {
        this.lastModifiedTime = new Date();
        if (this.isSynced != null) {
            this.isSynced = false;
        }
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\Task.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java
	 */

    private String outputHelpMessage(CommandType command) {
        switch (command) {
            case ADD :
                return this.printTableWithBorder(HelpMessage.ADD_START_INDEX,
                        HelpMessage.ADD_END_INDEX, HelpMessage.TABLE);
            case ALIAS :
                return this.printTableWithBorder(HelpMessage.ALIAS_INDEX,
                        HelpMessage.ALIAS_INDEX, HelpMessage.TABLE);
            case ALIAS_ADD :
                return this.printTableWithBorder(HelpMessage.ALIAS_ADD_INDEX,
                        HelpMessage.ALIAS_ADD_INDEX, HelpMessage.TABLE);
            case ALIAS_DELETE :
                return this.printTableWithBorder(
                        HelpMessage.ALIAS_DELETE_INDEX,
                        HelpMessage.ALIAS_DELETE_INDEX, HelpMessage.TABLE);
            case DELETE :
                return this.printTableWithBorder(HelpMessage.DELETE_INDEX,
                        HelpMessage.DELETE_INDEX, HelpMessage.TABLE);
            case DONE :
                return this.printTableWithBorder(HelpMessage.DONE_INDEX,
                        HelpMessage.DONE_INDEX, HelpMessage.TABLE);
            case EXIT :
                return this.printTableWithBorder(HelpMessage.EXIT_INDEX,
                        HelpMessage.EXIT_INDEX, HelpMessage.TABLE);
            case HELP :
                return this.printTableWithBorder(1, HelpMessage.EXIT_INDEX,
                        HelpMessage.TABLE);
            case HISTORY :
                return this.printTableWithBorder(HelpMessage.HISTORY_INDEX,
                        HelpMessage.HISTORY_INDEX, HelpMessage.TABLE);
            case HISTORY_CLEAR :
                return this.printTableWithBorder(
                        HelpMessage.HISTORY_CLEAR_INDEX,
                        HelpMessage.HISTORY_CLEAR_INDEX, HelpMessage.TABLE);
            case HISTORY_UNDO :
                return this.printTableWithBorder(
                        HelpMessage.HISTORY_UNDO_INDEX,
                        HelpMessage.HISTORY_UNDO_INDEX, HelpMessage.TABLE);
            case MODIFY :
                return this.printTableWithBorder(HelpMessage.MODIFY_INDEX,
                        HelpMessage.MODIFY_INDEX, HelpMessage.TABLE);
            case SEARCH :
                return this.printTableWithBorder(HelpMessage.SEARCH_INDEX,
                        HelpMessage.SEARCH_INDEX, HelpMessage.TABLE);
            case VIEW :
                return this.printTableWithBorder(HelpMessage.VIEW_INDEX,
                        HelpMessage.VIEW_INDEX, HelpMessage.TABLE);
            default :
                assert (false);
        }
        return null;

    }

    /**
     * TODO WHY IS THIS HERE? This method is used to print the table with
     * border. (modified from printTable)
     */
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java
	 */

    private String printTableWithBorder(int startIndex, int endIndex,
            String[][] table) {
        char borderKnot = '+';
        char horizontalBorder = '-';
        char verticalBorder = '|';
        int spaceInfront = 1;
        int spaceBehind = 2;
        char space = ' ';
        String newLine = "\n";
        StringBuilder sb = new StringBuilder();

        // Find out what the maximum number of columns is in any row
        int maxColumns = 0;
        for (String[] element : table) {
            maxColumns = Math.max(element.length, maxColumns);
        }

        // Find the maximum length of a string in each column
        int[] lengths = new int[maxColumns];
        for (int j = 0; j < maxColumns; j++) {
            lengths[j] = Math.max(table[0][j].length(), lengths[j]);
        }
        for (int i = startIndex; i <= endIndex; i++) {
            for (int j = 0; j < maxColumns; j++) {
                lengths[j] = Math.max(table[i][j].length(), lengths[j]);
            }
        }

        for (int j = 0; j < maxColumns; j++) {
            lengths[j] += spaceBehind;
        }

        // Print header
        for (int i = 0; i < maxColumns; i++) {
            sb.append(borderKnot);
            for (int j = 0; j < (lengths[i] + spaceInfront); j++) {
                sb.append(horizontalBorder);
            }
        }
        sb.append(borderKnot);
        sb.append(newLine);
        for (int i = 0; i < maxColumns; i++) {
            sb.append(verticalBorder);
            for (int k = 0; k < spaceInfront; k++) {
                sb.append(space);
            }
            sb.append(table[0][i]);
            for (int j = 0; j < (lengths[i] - table[0][i].length()); j++) {
                sb.append(space);
            }
        }
        sb.append(verticalBorder);
        sb.append(newLine);
        for (int i = 0; i < maxColumns; i++) {

            sb.append(borderKnot);
            for (int j = 0; j < (lengths[i] + spaceInfront); j++) {
                sb.append(horizontalBorder);
            }
        }
        sb.append(borderKnot);
        sb.append(newLine);

        // Print content (from startIndex to endIndex)
        for (int i = startIndex; i <= endIndex; i++) {
            sb.append(verticalBorder);
            for (int j = 0; j < maxColumns; j++) {
                for (int k = 0; k < spaceInfront; k++) {
                    sb.append(space);
                }
                sb.append(table[i][j]);
                for (int k = 0; k < (lengths[j] - table[i][j].length()); k++) {
                    sb.append(space);
                }
                sb.append(verticalBorder);
            }
            sb.append(newLine);

        }
        for (int i = 0; i < maxColumns; i++) {
            sb.append(borderKnot);
            for (int j = 0; j < (lengths[i] + spaceInfront); j++) {
                sb.append(horizontalBorder);
            }
        }
        sb.append(borderKnot);

        return sb.toString();
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java





