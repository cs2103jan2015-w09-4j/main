//@author: a0065517a



	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\data\AliasData.java
	 */

/**
 * This class contains all data about alias that are needed in alias-related
 * operation
 */
public class AliasData implements IStorableElement {

    private Map<String, String> aliasMap;

    /**
     * Default constructor of AliasData
     */
    public AliasData() {
        this.aliasMap = new HashMap<String, String>();
    }

    /**
     * Adds an alias to the data structure.
     *
     * @param alias
     *            the alias to associate with value.
     * @param value
     *            the value to associate with alias.
     * @return the previous value associated with alias, or null if there is
     *         none.
     */
    public String addAlias(String alias, String value) {
        assert (alias != null);
        assert (value != null);
        assert (!value.equals(""));
        assert (!value.equals(""));
        return this.aliasMap.put(alias, value);
    }

    /**
     * Deletes an alias.
     *
     * @param alias
     *            to be deleted.
     * @throws DataException
     *             when the alias does not exist.
     */
    public void deleteAlias(String alias) throws DataException {
        if (this.aliasMap.remove(alias) == null) {
            throw new DataException("Alias(" + alias + ") does not exist.");
        }
    }

    /**
     * Return the Alias Map
     *
     * @return the aliasMap
     */
    public Map<String, String> getAliasMap() {
        return this.aliasMap;
    }

    /**
     * Gets the set of <alias, value> mappings.
     *
     * @return set of <alias, value> mappings.
     */
    public Set<Map.Entry<String, String>> getAllAliases() {
        return this.aliasMap.entrySet();
    }

    /**
     * Checks if Alias Data is empty.
     *
     * @return <code>true</code> if empty, <code>false</code> otherwise.
     */
    public boolean isEmpty() {
        if (this.aliasMap == null) {
            return true;
        }
        return false;
    }

    /**
     * Check whether the data structure is valid return isValid
     */
    @Override
    public boolean isValid() {
        // checks the validity of the data structure
        // Ensures that the mapping does not contain any null keys or values.
        // check for a key that is null, that is illegal
        if (this.aliasMap.containsKey(null)) {
            return false;
        }
        if (this.aliasMap.containsValue(null)) {
            return false;
        }
        return true;
    }

    /**
     * Set the alias map to aliasMap
     *
     * @param aliasMap
     *            the aliasMap to set
     */
    public void setAliasMap(Map<String, String> aliasMap) {
        this.aliasMap = aliasMap;
    }

    /**
     * Finds the respective value for the alias.
     *
     * @param alias
     *            alias should exist in the data structure.
     * @return value mapped to alias.
     * @throws DataException
     *             when the alias does not exist.
     */
    public String toValue(String alias) throws DataException {
        assert (alias != null);
        String value = this.aliasMap.get(alias);
        if (value == null) {
            int length = alias.length();
            String subAlias = alias;
            while (length > 0) {
                subAlias = subAlias.substring(0, length);
                value = this.aliasMap.get(subAlias);
                if (value != null) {
                    return value + alias.substring(length, alias.length());
                }
                length--;
            }
            if (length == 0) {
                throw new DataException(
                        "No corresponding value for any sub-Alias of Alias("
                                + alias + ").");
            }
        }
        return value;
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\data\AliasData.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\ParseException.java
	 */

/**
 * Parse Exception is thrown when there is a problem with Parsing.
 */
public class ParseException extends Exception {

    /**
     *
     */
    private static final long serialVersionUID = 1L;

    /**
     * @param message
     */
    public ParseException(String message) {
        super(message);
    }

    /**
     * @param message
     * @param throwable
     */
    public ParseException(String message, Throwable throwable) {
        super(message, throwable);
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\ParseException.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\AliasParser.java
	 */

/**
 * Parser to replace all aliases with the actual value.
 */
public class AliasParser {

    /**
     * Regex to match all the escaped alias.
     *
     * <pre>
     *  <code>%1$s</code> is the alias character.
     * </pre>
     */
    private static final String ALIAS_ESCAPED_CHARACTER_REGEX_FORMAT = "\\\\%1$s";
    /**
     * Regex to match all valid alias, with its alias character
     *
     * <pre>
     *  <code>%1$s</code> is the alias character.
     * </pre>
     */
    private static final String ALIAS_REGEX_FORMAT = "(?<!\\\\)%1$s[^\\s%1$s]+";
    private static final Logger logger = LoggerFactory
            .getLogger(AliasParser.class);

    private Character aliasCharacter;
    private AliasData aliasData;
    private String aliasEscapedRegex;
    private Pattern aliasPattern;

    /**
     * Creates an Alias Parser with the alias config and data.
     *
     * @param aliasConfig
     *            configuration for the alias symbols.
     * @param aliasData
     *            data that has the pairings of <alias, value>.
     */
    public AliasParser(AliasConfig aliasConfig, AliasData aliasData) {

        this.aliasData = aliasData;
        this.aliasCharacter = aliasConfig.getAliasCharacter();

        // Create a StringBuilder and send all output to sb
        StringBuilder sb = new StringBuilder();

        try (Formatter formatter = new Formatter(sb, Locale.getDefault())) {

            // format the regex, entering the alias character into Regex
            formatter.format(ALIAS_REGEX_FORMAT, Pattern.quote(Character
                    .toString(aliasConfig.getAliasCharacter())));

            // Create the pattern object to store the Regex
            this.aliasPattern = Pattern.compile(sb.toString());
            logger.debug("Alias Regex(" + sb.toString() + ").");

            // reset the sb
            sb.setLength(0);

            // Format the escaped chracter Regex
            formatter
            .format(ALIAS_ESCAPED_CHARACTER_REGEX_FORMAT, Pattern
                    .quote(Character.toString(aliasConfig
                            .getAliasCharacter())));

            logger.debug("Escaped alias Regex(" + sb.toString() + ").");

            // Store only the regex, as we are going to use the function
            // replaceAll
            this.aliasEscapedRegex = sb.toString();
        }
    }

    /**
     * Checks if a given alias is valid. An alias is valid if and only if it
     * does not contain the alias character.
     *
     * @param alias
     * @return <code>true</code> if the alias is valid, <code>false</code>
     *         otherwise.
     */
    public boolean isValidAlias(String alias) {
        return !alias.contains(this.aliasCharacter.toString());
    }

    /**
     * Replaces all aliases in inputToReplace to its aliases, also unescapes all
     * escaped alias characters.
     *
     * @param inputToReplace
     *            the input string to replace aliases.
     * @return string with all aliases replaced with their actual text.
     * @throws DataException
     *             when the alias cannot be found in the lookup table.
     */
    public String replaceAllAlias(String inputToReplace) throws DataException {

        // Matcher to match aliases with their symbols
        Matcher aliasMatcher = this.aliasPattern.matcher(inputToReplace);

        // String builder to re-construct the string
        StringBuilder sb = new StringBuilder();
        int previousMatchEnd = 0;
        while (aliasMatcher.find()) {

            String eaAlias = aliasMatcher.group();
            sb.append(inputToReplace.substring(previousMatchEnd,
                    aliasMatcher.start()));

            // Alias's value, will throw exception if does not exist
            String eaAliasReplaced = this.aliasData.toValue(eaAlias
                    .substring(1));
            logger.debug("Replace Alias(" + eaAlias + ") with \""
                    + eaAliasReplaced + "\".");

            previousMatchEnd = aliasMatcher.end();
            sb.append(eaAliasReplaced);
        }

        // Replace all escaped alias characters with the alias character
        sb.append(inputToReplace.substring(previousMatchEnd));
        String replacedString = sb.toString().replaceAll(
                this.aliasEscapedRegex, this.aliasCharacter.toString());
        logger.info("\"" + inputToReplace + "\" was parsed to \""
                + replacedString + "\"");
        return replacedString;
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\AliasParser.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AddStatement.java
	 */

/**
 * Class to encapsulate an add statement. Add statements must be matchable to
 * the following regex: ^add\s[A-Za-z0-9]+$ .
 */
public class AddStatement extends Statement {

    private static Logger logger = LoggerFactory.getLogger(AddStatement.class);
    private Task task;

    /**
     * Initializes an add statement, ensures that the add statement is a valid
     * statement, the task that is added must either be:
     *
     * <pre>
     * 1. Floating Task
     * 2. Deadline Task
     * 3. Timed Task(Event)
     * </pre>
     *
     * Each would also have the option to specify a recursion.
     *
     * @param statementString
     *            the string to be added.
     * @throws Exception
     */
    public AddStatement(String statementString) throws Exception {
        super(CommandType.ADD, statementString);
        this.task = new Task();
        ParameterParser parameterParser = Parser.getInstance()
                .getStatementParser().getParameterParser();
        ParameterContainer container = parameterParser.parse(this
                .getStatementArgumentsOnly());
        container.addAll(this.task);
        this.task.toCompleteTask();
        if (this.task.getTaskType() == Task.TaskType.INCOMPLETE) {
            throw new ParseException(
                    "Task added must be a Complete tasks of the 3 types.");
        }
        logger.debug("Valid add Command, parsed \"" + statementString
                + "\": task=" + new Gson().toJson(this.task));
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo) {
        // Statement to be added
        // a new Task is created so that the internal implementation is not
// affected.
        return taskManager.add(new Task(this.task), this, isUndo);
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AddStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AliasStatement.java
	 */

/**
 * Alias Statement has no parameters.
 */
public class AliasStatement extends StatementNoParams {

    private static Logger logger = LoggerFactory
            .getLogger(AliasStatement.class);

    /**
     * Creates a new alias statement.
     *
     * @param statementString
     */
    public AliasStatement(String statementString) {
        super(CommandType.ALIAS, statementString);
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo) {
        return taskManager.alias(this);
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\AliasStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\CommandType.java
	 */

/**
 * Classifies the commands that can be passed in from the user. The list of
 * command accepted are described in this enum:
 *
 * <pre>
 * 1. add
 * 2. alias
 * 3. alias-add
 * 4. alias-delete
 * 5. delete
 * 6. done
 * 7. exit
 * 8. help
 * 9. history
 * 10. history-clear
 * 11. history-undo
 * 12. modify
 * 13. search
 * 14. view
 * </pre>
 */
public enum CommandType {

    /**
     * Adds a task to the task manager. It can add floating task, deadline task,
     * timed task, recurring deadline task or recurring timed task.
     */
    ADD("add"),
    /**
     * List all the aliases in the database.
     */
    ALIAS("alias"),
    /**
     * Adds a new alias to the database.
     */
    ALIAS_ADD("alias-add"),
    /**
     * Deletes a alias from the database.
     */
    ALIAS_DELETE("alias-delete"),
    /**
     * Deletes a task and moves it to the tasks recycle bin.
     */
    DELETE("delete"),
    /**
     * Done command is run when the task is completed.
     */
    DONE("done"),
    /**
     * Exits the task manager.
     */
    EXIT("exit"),
    /**
     * Displays the command syntax and example.
     */
    HELP("help"),
    /**
     * Displays the current history of actions.
     */
    HISTORY("history"),
    /**
     * Clears one, a range or all history.
     */
    HISTORY_CLEAR("history-clear"),
    /**
     * Undo one history action.
     */
    HISTORY_UNDO("history-undo"),
    /**
     * Modifies the task specified, updating the details of the tasks.
     */
    MODIFY("modify"),
    /**
     * Search for a particular task in the task manager.
     */
    SEARCH("search"),
    /**
     * Lists the tasks in the task manager, giving the option to display in
     * different formats.
     */
    VIEW("view");

    private final String commandName;

    private CommandType(String commandName) {
        this.commandName = commandName;
    }

    @Override
    public String toString() {
        return this.commandName;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\CommandType.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\ExitStatement.java
	 */

/**
 * Class to encapsulate an exit statement.
 */
public class ExitStatement extends StatementNoParams {

    /**
     * Creates a new exit Statement.
     *
     * @param statementString
     */
    public ExitStatement(String statementString) {
        super(CommandType.EXIT, statementString);
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo) {
        return taskManager.exit(this);
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\ExitStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HistoryStatement.java
	 */

/**
 * History Statement has no parameters.
 */
public class HistoryStatement extends StatementNoParams {

    private static Logger logger = LoggerFactory
            .getLogger(HistoryStatement.class);

    /**
     * Creates a new history Statement.
     *
     * @param statementString
     */
    public HistoryStatement(String statementString) {
        super(CommandType.HISTORY, statementString);
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws CommandExecuteException {
        return taskManager.viewHistory(this);
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\HistoryStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\ModifyStatement.java
	 */

/**
 * Class to encapsulate a modify statement. Essentially a modify statement is an
 * add statement with a query. The syntax must be in the form:
 *
 * <pre>
 * \<modify\> \<query\> \<parameters\>
 * </pre>
 */
public class ModifyStatement extends Statement {

    private static Logger logger = LoggerFactory
            .getLogger(ModifyStatement.class);

    private String query;

    private Task task;

    /**
     * Initializes a modify statement, parses the query first.
     *
     * @param statementString
     * @throws ParseException
     * @exception InvalidParameterException
     *                if the parameters does not exist.
     */
    public ModifyStatement(String statementString) throws ParseException {
        super(CommandType.MODIFY, statementString);
        ParameterParser parameterParser = Parser.getInstance()
                .getStatementParser().getParameterParser();
        Matcher queryMatcher = Pattern.compile(",").matcher(
                this.getStatementArgumentsOnly());

        if (queryMatcher.find()) {
            this.query = this.getStatementArgumentsOnly().substring(0,
                    queryMatcher.start());
        } else {
            throw new ParseException(
                    "Modify statement must contain query argument.");
        }

        this.task = new Task();
        ParameterContainer container = parameterParser.parse(this
                .getStatementArgumentsOnly().substring(queryMatcher.end()));
        container.addAll(this.task);

        logger.debug("Valid modify Command, parsed \"" + statementString
                + "\": query=\"" + this.query + "\" task="
                + new Gson().toJson(this.task));

    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws CommandExecuteException, DataException {
        // Statement to be added
        return taskManager
                .modify(this.query, new Task(this.task), this, isUndo);

    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\ModifyStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\CategoryParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import w094j.ctrl8.pojo.Task;

/**
 */
public class CategoryParameter extends Parameter {

    /**
     * @param payload
     */
    public CategoryParameter(String payload) {
        super(ParameterType.CATEGORY, payload);
    }

    @Override
    public void add(Task task) {
        task.setCategory(this.getPayload());
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\CategoryParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\DeadlineParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import w094j.ctrl8.pojo.Task;

/**
 */
public class DeadlineParameter extends ParameterDatePayload {

    /**
     * @param payload
     */
    public DeadlineParameter(String payload) {
        super(ParameterType.DEADLINE, payload);
    }

    @Override
    public void add(Task task) {
        task.setEndDate(this.getDate());
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\DeadlineParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\DescriptionParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import w094j.ctrl8.pojo.Task;

/**
 */
public class DescriptionParameter extends Parameter {

    /**
     * @param payload
     */
    public DescriptionParameter(String payload) {
        super(ParameterType.DESCRIPTION, payload);
    }

    @Override
    public void add(Task task) {
        task.setDescription(this.getPayload());
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\DescriptionParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\LocationParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import w094j.ctrl8.pojo.Task;

/**
 */
public class LocationParameter extends Parameter {

    /**
     * @param payload
     */
    public LocationParameter(String payload) {
        super(ParameterType.LOCATION, payload);
    }

    @Override
    public void add(Task task) {
        task.setLocation(this.getPayload());
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\LocationParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\Parameter.java
	 */

/**
 * Represents a parameter, its symbol with its payload. This class presents no
 * understanding of the payload.
 */
public abstract class Parameter {

    private String payload;
    private ParameterType symbol;

    /**
     * Creates a Parameter. The syntax accepted on the command line is
     *
     * <pre>
     * \<symbol\>{\<payload\>}
     * </pre>
     *
     * @param symbol
     * @param payload
     */
    public Parameter(ParameterType symbol, String payload) {
        assert (symbol != null);
        assert (payload != null);
        this.symbol = symbol;

        // Nullify the string if it is empty
        if (payload.equals("")) {
            this.payload = null;
        } else {
            ParameterParser parameterParser = Parser.getInstance()
                    .getStatementParser().getParameterParser();
            this.payload = parameterParser.unescape(payload);
        }
    }

    /**
     * Adds the current parameter to the task specified.
     *
     * @param task
     *            to add the tasks.
     */
    public abstract void add(Task task);

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Parameter) {
            Parameter objParameter = (Parameter) obj;
            if ((objParameter.symbol.equals(this.symbol) && (((this.payload == null) && (objParameter.payload == this.payload)) || objParameter.payload
                    .equals(this.payload)))) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * @return the payload
     */
    public String getPayload() {
        return this.payload;
    }

    /**
     * @return the symbol
     */
    public ParameterType getSymbol() {
        return this.symbol;
    }

    /**
     * @param payload
     *            the payload to set
     */
    public void setPayload(String payload) {
        this.payload = payload;
    }

    /**
     * @param symbol
     *            the symbol to set
     */
    public void setSymbol(ParameterType symbol) {
        this.symbol = symbol;
    }

    @Override
    public String toString() {
        return this.symbol.toString() + "{" + this.payload + "}";
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\Parameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ParameterContainer.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import w094j.ctrl8.exception.ParseException;
import w094j.ctrl8.pojo.Task;

/**
 * A Container that will handle the all the different parameters, and is
 * responsible to adding all these to a task. Moreover, it will also check that
 * each parameter appears only once.
 */
public class ParameterContainer {

    private Map<ParameterType, Parameter> parameterLookup;

    /**
     * Initializes the list of parameters to this container.
     *
     * @param parameterList
     *            the list to use to initialize the container.
     * @throws ParseException
     *             if some parameter has a duplicate.
     */
    public ParameterContainer(List<Parameter> parameterList)
            throws ParseException {
        this.parameterLookup = new HashMap<ParameterType, Parameter>();
        for (Parameter eaParameter : parameterList) {
            if (this.parameterLookup.put(eaParameter.getSymbol(), eaParameter) != null) {
                throw new ParseException("Parameters cannot be repeated.");
            }
        }
    }

    /**
     * Adds all the parameters to the task specified.
     *
     * @param task
     *            task to add the parameters to.
     */
    public void addAll(Task task) {
        for (Parameter eaParameter : this.parameterLookup.values()) {
            eaParameter.add(task);
        }
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof ParameterContainer) {
            ParameterContainer paramContainerObj = (ParameterContainer) obj;
            return (this.parameterLookup
                    .equals(paramContainerObj.parameterLookup));
        }
        return false;
    }

    @Override
    public String toString() {
        return this.parameterLookup.toString();
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ParameterContainer.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ParameterDatePayload.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import java.security.InvalidParameterException;
import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * Parameter with a Date payload.
 */
public abstract class ParameterDatePayload extends Parameter {

    private Date date;

    /**
     * Initializes and parses the payload to be a date and time.
     *
     * @param symbol
     *            symbol of the calling environment.
     * @param payload
     *            payload to be parsed into date and time.
     */
    public ParameterDatePayload(ParameterType symbol, String payload) {
        super(symbol, payload);

        // if the payload is defined
        if (!payload.isEmpty()) {
            // Parses the date using the method specified on Natty.
            // with references to sample code at http://natty.joestelmach.com/
            List<DateGroup> groups = new Parser().parse(payload);
            if (groups.size() != 1) {
                throw new InvalidParameterException(
                        "Each tag must have a date/time.");
            }
            DateGroup group = groups.get(0);

            List<Date> dates = group.getDates();
            if (dates.size() != 1) {
                throw new InvalidParameterException(
                        "Each tag must have a date/time.");
            }

            this.date = dates.get(0);
        }
    }

    /**
     * @return the date
     */
    public Date getDate() {
        return this.date;
    }

    /**
     * @param date
     *            the date to set
     */
    public void setDate(Date date) {
        this.date = date;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ParameterDatePayload.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ParameterType.java
	 */

package w094j.ctrl8.parse.statement.parameter;

/**
 * Enum to classify the different kinds of parameter symbols.
 */
public enum ParameterType {

    /**
     * Category of the task. Inspiration from twitter! #HASHTAG!
     */
    CATEGORY,
    /**
     * Deadline of the task, it can also mean the end time when used in
     * conjunction with START_TIME. - looks like a knife going across your
     * throat, if you do not complete by then... Then you will die!
     */
    DEADLINE,
    /**
     * Description of the task. Need more details? +, which means add, add more
     * details!
     */
    DESCRIPTION,
    /**
     * Description of the task. @ is the at sign, which can conveniently replace
     * the word 'at'. I am @ School.
     */
    LOCATION,
    /**
     * Priority of the task. % is the percent sign, which will tell you
     * percentage importance.
     */
    PRIORITY,
    /**
     * Sets a Reminder for the task. ! is a symbol one would observe in an
     * important email, reminding the user to reply or die.
     */
    REMINDER,
    /**
     * Start time of the task. Well, ~ seems cool to denote start time.
     */
    START_TIME,
    /**
     * Title of the task. = is used in equations, and on the right hand side you
     * will have a nice evaluated answer, which 'sums' up the whole problem.
     * Similarly, a title 'sums' up the whole task.
     */
    TITLE;
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ParameterType.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\PriorityParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import java.security.InvalidParameterException;

import w094j.ctrl8.pojo.Task;

/**
 * Priority must be a number between 0 and 10, including the limits.
 */
public class PriorityParameter extends Parameter {

    private Integer priority;

    /**
     * Creates a new Priority Parameter.
     *
     * @param payload
     *            to be parsed to 0 to 10.
     */
    public PriorityParameter(String payload) {
        super(ParameterType.PRIORITY, payload);
        if (!payload.isEmpty()) {
            try {
                this.priority = Integer.parseInt(this.getPayload());
            } catch (NumberFormatException nfe) {
                throw new InvalidParameterException(
                        "Priority must be an integer.");
            }

            if ((this.priority < 0) || (this.priority > 10)) {
                throw new InvalidParameterException(
                        "Priority must be between and inclusive of 0 and 10. 0 <= priority <= 10");
            }
        }

    }

    @Override
    public void add(Task task) {
        task.setPriority(this.priority);
    }

    /**
     * @return the priority
     */
    public int getPriority() {
        return this.priority;
    }

    /**
     * @param priority
     *            the priority to set
     */
    public void setPriority(int priority) {
        this.priority = priority;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\PriorityParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ReminderParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import w094j.ctrl8.pojo.Task;

/**
 */
public class ReminderParameter extends ParameterDatePayload {

    /**
     * @param payload
     */
    public ReminderParameter(String payload) {
        super(ParameterType.REMINDER, payload);
    }

    @Override
    public void add(Task task) {
        task.setReminder(this.getDate());
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\ReminderParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\StartTimeParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import w094j.ctrl8.pojo.Task;

/**
 */
public class StartTimeParameter extends ParameterDatePayload {

    /**
     * @param payload
     */
    public StartTimeParameter(String payload) {
        super(ParameterType.START_TIME, payload);
    }

    @Override
    public void add(Task task) {
        task.setStartDate(this.getDate());
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\StartTimeParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\TitleParameter.java
	 */

package w094j.ctrl8.parse.statement.parameter;

import w094j.ctrl8.pojo.Task;

/**
 */
public class TitleParameter extends Parameter {

    /**
     * @param payload
     */
    public TitleParameter(String payload) {
        super(ParameterType.TITLE, payload);
        if (payload == null) {
            throw new RuntimeException("s");
        }
    }

    @Override
    public void add(Task task) {
        task.setTitle(this.getPayload());
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\parameter\TitleParameter.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\SearchStatement.java
	 */

/**
 * Represents a Search Statement
 */
public class SearchStatement extends StatementQuery {

    private static Logger logger = LoggerFactory
            .getLogger(SearchStatement.class);
    private String query;

    /**
     * @param statementString
     */
    public SearchStatement(String statementString) {
        super(CommandType.SEARCH, statementString);
        this.query = this.getStatementArgumentsOnly();
        logger.debug("Valid search Command, query \"" + statementString + "\"");
    }

    @Override
    public Response execute(ITaskManager taskManager, boolean isUndo)
            throws DataException {
        // Statement to be added
        return taskManager.search(this.query, this);
    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\SearchStatement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\Statement.java
	 */

/**
 * Abstract Class to encapsulate a statement, which composes of its command and
 * its parameter(s). The handling of the parameters is to be handled at its
 * subclasses.
 */
public abstract class Statement {

    private static Logger logger = LoggerFactory.getLogger(Statement.class);

    // command of the statement
    private CommandType command;
    // without command, arguments only
    private String statementArgumentsOnly;

    /**
     * Creates an Statement object with the Command and arguments
     *
     * @param command
     */
    protected Statement(CommandType command, String statementString) {
        this.command = command;
        CommandParser commandParser = Parser.getInstance().getStatementParser()
                .getCommandParser();
        this.statementArgumentsOnly = commandParser
                .removeCommandKeyword(statementString);
        logger.debug("Statement initialized with Command(" + this.command
                + ") and arguments " + this.statementArgumentsOnly);
    }

    /**
     * Executes the command in the specified terminal, performing the specific
     * command related to the respective commands.
     *
     * @param taskManager
     *            to execute the command in.
     * @throws DataException
     * @throws CommandExecuteException
     *             when the execution of the command has problems.
     */
    public abstract Response execute(ITaskManager taskManager, boolean isUndo)
            throws DataException, CommandExecuteException;

    /**
     * @return the command
     */
    public CommandType getCommand() {
        return this.command;
    }

    /**
     * @return the statementArgumentsOnly
     */
    public String getStatementArgumentsOnly() {
        return this.statementArgumentsOnly;
    }

    /**
     * @param command
     *            the command to set
     */
    public void setCommand(CommandType command) {
        this.command = command;
    }

    /**
     * @param statementArgumentsOnly
     *            the statementArgumentsOnly to set
     */
    public void setStatementArgumentsOnly(String statementArgumentsOnly) {
        this.statementArgumentsOnly = statementArgumentsOnly;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\Statement.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\StatementNoParams.java
	 */

/**
 * Abstract Class to encapsulate a statement which has no parameters.
 */
public abstract class StatementNoParams extends Statement {

    /**
     * Creates a Statement without parameters, checks the statementString for
     * any parameters. If there are parameters, fail immediately.
     *
     * @param command
     *            Command type.
     * @param statementString
     *            The statement that the user entered into the terminal.
     */
    public StatementNoParams(CommandType command, String statementString) {
        super(command, statementString);
        if (!this.getStatementArgumentsOnly().isEmpty()) {
            throw new InvalidParameterException(command
                    + " does not take in any parameters.");
        }
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\parse\statement\StatementNoParams.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\DateIntervalNode.java
	 */

/**
 * Date Interval node to represent each interval on the tree.
 */
class DateIntervalNode {

    Date endDate;
    DateIntervalNode leftSubTree;
    Date maxEndDate;
    DateIntervalNode rightSubTree;
    Date startDate;

    DateIntervalNode(DateIntervalNode left, Date startDate, Date endDate,
            Date maxEndDate, DateIntervalNode right) {
        this.leftSubTree = left;
        this.startDate = startDate;
        this.endDate = endDate;
        this.maxEndDate = maxEndDate;
        this.rightSubTree = right;
    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\DateIntervalNode.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\DateIntervalTree.java
	 */

/**
 * Tree to sort out the intervals.
 */
public class DateIntervalTree {

    private DateIntervalNode rootNode;

    /**
     * Initializes an empty tree.
     */
    public DateIntervalTree() {
    }

    /**
     * Initializes a tree with the task array.
     *
     * @param taskArray
     */
    public DateIntervalTree(Task[] taskArray) {
        this.addAll(taskArray);
    }

    /**
     * Add all tasks to the interval tree, if there is an interval to add in
     * each task.
     *
     * @param taskArray
     */
    public void addAll(Task[] taskArray) {
        // Filter the timed tasks
        for (Task eaTask : taskArray) {
            if (eaTask.getTaskType().equals(Task.TaskType.TIMED)) {
                this.addInterval(eaTask);
            }
        }
    }

    /**
     * Traverse the tree and update the maxEndDate and also appending the task
     * with the range to the tree when needed.
     *
     * @param task
     */
    public void addInterval(Task task) {

        Date startDate = task.getStartDate();
        Date endDate = task.getEndDate();

        DateIntervalNode newLeaf = new DateIntervalNode(null, startDate,
                endDate, endDate, null);

        DateIntervalNode currentNode = this.rootNode;
        while (currentNode != null) {

            // Update the max along the way
            if (endDate.after(currentNode.maxEndDate)) {
                currentNode.maxEndDate = endDate;
            } else {
                currentNode.maxEndDate = currentNode.maxEndDate;
            }

            // Update the subTree with the new leaf
            if (startDate.before(currentNode.startDate)) {
                if (currentNode.leftSubTree == null) {
                    currentNode.leftSubTree = newLeaf;
                    return;
                } else {
                    currentNode = currentNode.leftSubTree;
                }
            } else {
                if (currentNode.rightSubTree == null) {
                    currentNode.rightSubTree = newLeaf;
                    return;
                } else {
                    currentNode = currentNode.rightSubTree;
                }
            }
        }

        // Can only reach here if rootNode is null
        this.rootNode = newLeaf;
    }

    /**
     * Check if the current date range in task is overlapped in the tree.
     *
     * @param task
     * @return <code>true</code> if there is an overlap, <code>false</code>
     *         otherwise.
     */
    public boolean isOverlap(Task task) {

        Date startDate = task.getStartDate();
        Date endDate = task.getEndDate();

        DateIntervalNode currentNode = this.rootNode;
        while (currentNode != null) {

            // If the dates are in-between the ranges
            if ((startDate.before(currentNode.endDate))
                    && (endDate.after(currentNode.startDate))) {
                return true;
            }

            // update the current node, traverse down the right sub tree
            if ((currentNode.leftSubTree != null)
                    && (currentNode.leftSubTree.maxEndDate.after(startDate))) {
                currentNode = currentNode.leftSubTree;
            } else {
                currentNode = currentNode.rightSubTree;
            }
        }
        return false;
    }

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\DateIntervalTree.java





