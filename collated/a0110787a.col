//@author: a0110787a



	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DisplayControllerConfig.java
	 */

package w094j.ctrl8.database.config;

import w094j.ctrl8.database.IStorableElement;

/**
 * Configures the Display Controller.
 */
public class DisplayControllerConfig implements IStorableElement {
    private GUITextDisplayConfig textDisplayConfig;
    private GUITextInputConfig textInputConfig;

    /**
     * Initializes the DisplayController.
     */
    public DisplayControllerConfig() {
        this.textDisplayConfig = new GUITextDisplayConfig();
        this.textInputConfig = new GUITextInputConfig();
    }

    /**
     * @return
     */
    public GUITextDisplayConfig getGUITextDisplayConfig() {
        return this.getGUITextDisplayConfig();
    }

    /**
     * @return
     */
    public GUITextInputConfig getGUITextInputConfig() {
        return this.getGUITextInputConfig();
    }

    @Override
    public boolean isValid() {
        return (this.textDisplayConfig == null ? true : this.textDisplayConfig
                .isValid())
                && (this.textInputConfig == null ? true : this.textInputConfig
                        .isValid());
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DisplayControllerConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUIDisplayConfig.java
	 */

package w094j.ctrl8.database.config;

import w094j.ctrl8.database.IStorableElement;

/**
 * This is a wrapper class that contains all configuration objects relating to
 * the GUIDisplay component.
 */
public class GUIDisplayConfig implements IStorableElement {
    protected static String[] DEFAULT_ARGS = new String[] { "" };

    protected String[] appArgs;
    protected DisplayControllerConfig controllerConfig;

    /**
     * The one and only constructor. Produces a default configuration.
     */
    public GUIDisplayConfig() {
        this.controllerConfig = new DisplayControllerConfig();
    }

    /**
     * @return application arguements.
     */
    public String[] getAppArgs() {
        if (this.appArgs == null) {
            return DEFAULT_ARGS;
        } else {
            return this.appArgs;
        }
    }

    @Override
    public boolean isValid() {
        return ((this.controllerConfig != null) && this.controllerConfig
                .isValid());
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUIDisplayConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUITextDisplayConfig.java
	 */

package w094j.ctrl8.database.config;

import w094j.ctrl8.database.IStorableElement;

/**
 * Config for the GUI Text Display.
 */
public class GUITextDisplayConfig extends GUITextGenericConfig implements
IStorableElement {
    // Uses a different set of default values
    protected static final TextColour DEFAULT_TEXT_COLOUR = TextColour.Black;
    protected static final int DEFAULT_TEXT_SIZE = 12;

    GUITextDisplayConfig() {
    }

    GUITextDisplayConfig(TextColour textColour, int textSize) {
        super(textColour, textSize);
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUITextDisplayConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUITextGenericConfig.java
	 */

package w094j.ctrl8.database.config;

import w094j.ctrl8.database.IStorableElement;

/**
 * Configs the GUI text Generic.
 */
public abstract class GUITextGenericConfig implements IStorableElement {
    /**
     * Text Color
     */
    @SuppressWarnings("javadoc")
    public enum TextColour {
        Awesome("orange"), Black("black"), Default("black"), Invalid("");

        private String textColour;

        TextColour(String textColour) {
            this.textColour = textColour;
        }

        @Override
        public String toString() {
            return this.textColour;
        }
    };

    protected static final TextColour DEFAULT_TEXT_COLOUR = GUITextGenericConfig.TextColour.Default;
    protected static final int DEFAULT_TEXT_SIZE = 10;
    protected TextColour textColour;
    protected Integer textSize;

    /**
     *
     */
    public GUITextGenericConfig() {
    }

    /**
     * @param textColour
     * @param textSize
     */
    public GUITextGenericConfig(TextColour textColour, int textSize) {
        this.setTextSize(textSize);
        this.setTextColour(textColour);
    }

    /**
     * @return textClour
     */
    public TextColour getTextColour() {
        if (this.textColour == null) {
            return DEFAULT_TEXT_COLOUR;
        } else {
            return this.textColour;
        }
    }

    /**
     * @return textSize
     */
    public int getTextSize() {
        if (this.textSize == null) {
            return DEFAULT_TEXT_SIZE;
        } else {
            return this.textSize;
        }
    }

    @Override
    public boolean isValid() {
        return this.textSize > 0;
    }

    /**
     * @param newColour
     */
    public void setTextColour(TextColour newColour) {
        this.textColour = newColour;
    }

    /**
     * @param textSize
     */
    public void setTextSize(int textSize) {
        if ((textSize > 32) || (textSize < 5)) {
            this.textSize = DEFAULT_TEXT_SIZE;
        } else {
            this.textSize = textSize;
        }
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUITextGenericConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUITextInputConfig.java
	 */

package w094j.ctrl8.database.config;

import w094j.ctrl8.database.IStorableElement;

/**
 * GUI Text Input
 */
public class GUITextInputConfig extends GUITextGenericConfig implements
        IStorableElement {
    // Uses a different set of default values
    protected static final TextColour DEFAULT_TEXT_COLOUR = TextColour.Black;
    protected static final int DEFAULT_TEXT_SIZE = 20;

    GUITextInputConfig() {
    }

    GUITextInputConfig(TextColour textColour, int textSize) {
        super(textColour, textSize);
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\GUITextInputConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java
	 */

    private String lastMessage;

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java
	 */

    /**
     * For testing purposes. Facilitates JUnit testing of individual modules
     * using CLIDisplay
     *
     * @return lastMessage
     */
    public String getLastMessage() {
        return this.lastMessage;

    }

    @Override
    public void goodbye() {
        // TODO Not Implemented Yet

    }

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java
	 */

    /**
     * For testing purposes. see getLastMessage()
     *
     * @param message
     */
    public void outputMessage(String message) {

        this.lastMessage = message;

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\Display.java
	 */

package w094j.ctrl8.display;

import java.io.InputStream;

import org.apache.commons.lang.NotImplementedException;

import w094j.ctrl8.database.config.DisplayConfig;
import w094j.ctrl8.pojo.Response;

/**
 * This abstract class defines the possible interactions a Terminal object use
 * to communicate with a Display Object. All Display classes should extend from
 * this abstract class to acheive the singleton pattern, avoiding multiple
 * instances of Display objects existing concurrently.
 */
public abstract class Display {

    private static Display instance;

    /**
     * Gets the current instance of the Display.
     *
     * @return the current instance.
     */
    public static Display getInstance() {
        if (instance == null) {
            throw new RuntimeException(
                    "Display must be initialized before retrieveing.");
        }
        return instance;
    }

    /**
     * Initializes an instance of Display given a displayConfig
     *
     * @param displayConfig
     * @return display
     */
    public static Display initInstance(DisplayConfig displayConfig) {

        if (instance != null) {
            throw new RuntimeException(
                    "Cannot initialize Display as it was initialized before.");
        } else {
            if (displayConfig.isGUI()) {
// instance = new GUIDisplay(displayConfig.getGUI());
                throw new NotImplementedException(
                        "GUI is under test, disabled.");
            } else {
                instance = new CLIDisplay(displayConfig.getCLI());
            }
        }
        return instance;

    }

    /**
     * Gets the inputstream of the Display object. The primary method of getting
     * input from user.
     *
     * @return InputStream user input as an inputstream.
     */
    public abstract InputStream getInputStream();

    /**
     * Informs the UI to display a goodbye message to the user.
     */
    public abstract void goodbye();

    /**
     * Prompts the user for input and gets an response.
     *
     * @param <T>
     *            Type of object to return from the user input.
     * @param prompt
     * @return The parsed result.
     */
    public abstract <T> T promptUser(Prompt<T> prompt);

    /**
     * Informs the UI to update itself with the response object provided after
     * an executation of a statement. If no commands are detected, then it will
     * just print the task table. Refer to w094j.ctrl8.pojo.Response.java for
     * more information.
     *
     * @param res
     *            The response POJO which lists all the variables that a
     *            response may contain.
     */
    public abstract void updateUI(Response res);

    /**
     * Informs the UI to display a welcome message to the user.
     */
    public abstract void welcome();

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\Display.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\GUICore.java
	 */

package w094j.ctrl8.display.gui;

import java.io.IOException;
import java.io.InputStream;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import w094j.ctrl8.database.config.GUIDisplayConfig;
import w094j.ctrl8.display.gui.view.ConsoleSceneController;
import w094j.ctrl8.display.gui.view.LocalResource;
import w094j.ctrl8.message.NormalMessage;

/**
 * The application core of the GUI implementation. To create an application
 * window, simply initialise the object using its constructor
 * GUICore(<GUIDisplayConfig>,<Thread>). Do not used its default constructor as
 * that is reserved for Application.launch.
 *
 * <pre>
 * Refer to
 * http://docs.oracle.com/javase/8/javafx/api/javafx/application/Application.html
 * </pre>
 */
public class GUICore extends Application implements Runnable {

    private static final String __newline = "\n";
// TODO
    private static ConsoleSceneController consoleController;
    private static Logger logger = LoggerFactory.getLogger(GUICore.class);
    private GUIDisplayConfig config;
    private Thread main;
    private Stage primaryStage; // Default stage
    private BorderPane rootLayout; // Wrapper for internal components

    public GUICore() {
        /*
         * To be left empty. Because Application.launch invokes the default
         * constructor, but we use the loaded constructor to initialise the
         * application
         */
    }

    public GUICore(GUIDisplayConfig config, Thread main) {
        this.config = config;
        this.main = main;
    }

    /**
     * @return the consoleController
     */
    public ConsoleSceneController getConsoleController() {
        return this.consoleController;
    }

    /**
     * Generates initial text to display in TextArea textDisplay.
     *
     * @return String
     */
    public String getConsoleInitString() {
        return NormalMessage.WELCOME_MESSAGE + __newline;
    }

    public InputStream getInputStream() {
        return this.getConsoleController().getInputStream();
    }

    /**
     * Returns the main stage. Main purpose is to allow child-scenes to be able
     * to link back.
     *
     * @return
     */
    public Stage getPrimaryStage() {
        return this.primaryStage;
    }

    @Override
    public void init() throws Exception {
        logger.debug("Initialising GUICore...");
        super.init();

        this.getParameters().getRaw();

        logger.debug("GUICore initialised!");
    }

    @Override
    public void run() {
        launch(this.config.getAppArgs());
    }

    /**
     * @param consoleController
     *            the consoleController to set
     */
    public void setConsoleController(ConsoleSceneController consoleController) {
        this.consoleController = consoleController;
    }

    @Override
    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.primaryStage.setTitle(NormalMessage.APP_NAME);

        this.initRootLayout();

        this.showConsole();

        synchronized (this) {
            this.notify();
        }
    }

    /**
     * Initialises the rootlayout
     */
    private void initRootLayout() {
        try {
            // Load root layout from fxml file
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(GUICore.class
                    .getResource(LocalResource.RootLayout));
            this.rootLayout = (BorderPane) loader.load();

            // Show the scene containing the root layout
            Scene rootLayoutScene = new Scene(this.rootLayout);
            this.primaryStage.setScene(rootLayoutScene);

            this.primaryStage.setResizable(true); /*
                                                   * Enable resizing the window
                                                   */
            this.primaryStage.show();

            this.primaryStage.setMinHeight(this.primaryStage.getHeight());
            this.primaryStage.setMinWidth(this.primaryStage.getWidth());
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    /**
     * Shows the console inside the root layout
     */
    private void showConsole() {
        try {
            // Load console scene
            FXMLLoader loader = new FXMLLoader();
            loader.setLocation(GUICore.class
                    .getResource(LocalResource.ConsoleScene));
            BorderPane consoleScene = (BorderPane) loader.load();

            consoleScene
                    .setStyle("-fx-faint-focus-color: transparent;-fx-focus-color: transparent;");

            // Place console scene in center pane of the rootLayout
            this.rootLayout.setCenter(consoleScene);

            // Give controller access
            this.setConsoleController(loader.getController());
            this.getConsoleController().setRoot(this);

        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\GUICore.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\model\FXTextFieldInputStream.java
	 */

package w094j.ctrl8.display.gui.model;

import java.io.IOException;
import java.io.InputStream;

import javafx.event.EventHandler;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * InputStream that takes a JavaFX TextField object as input, and provides a
 * means of reading it like a typical InputStream.
 */
public class FXTextFieldInputStream extends InputStream {
    byte[] contents;
    int pointer = 0;

    private Logger logger = LoggerFactory
            .getLogger(FXTextFieldInputStream.class);

    public FXTextFieldInputStream(final TextField text) {
        this.contents = new byte[] {};
        this.pointer = 1;
        text.addEventHandler(KeyEvent.KEY_PRESSED,
                new EventHandler<KeyEvent>() {

                    @Override
                    public void handle(KeyEvent event) {
                        if (event.getCode() == KeyCode.ENTER) {
                            FXTextFieldInputStream.this.contents = (text
                                    .getText() + "\n").getBytes();
                            FXTextFieldInputStream.this.pointer = 0;
                            text.setText("");

                            synchronized (FXTextFieldInputStream.this) {
                                FXTextFieldInputStream.this.notifyAll();
                            }
                        }
                    }
                });
    };

    // Disables the default constructor
    @SuppressWarnings("unused")
    private FXTextFieldInputStream() {
    }

    @Override
    public int read() throws IOException {
        if (this.pointer == this.contents.length) {
            this.pointer++;
            return -1;
        }
        if (this.pointer > this.contents.length) {
            synchronized (this) {
                try {
                    this.wait();
                    this.pointer = 0;
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    return -1;
                }
            }
        }
        return this.contents[this.pointer++];
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\model\FXTextFieldInputStream.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\view\ConsoleSceneController.java
	 */

package w094j.ctrl8.display.gui.view;

import java.io.InputStream;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import w094j.ctrl8.database.config.DisplayControllerConfig;
import w094j.ctrl8.database.config.GUITextDisplayConfig;
import w094j.ctrl8.database.config.GUITextInputConfig;
import w094j.ctrl8.display.gui.GUICore;
import w094j.ctrl8.display.gui.model.FXTextFieldInputStream;

/**
 * Controller class for the JavaFX Application. Manages capturing input from
 * Application window as well as updating its view.
 */
public class ConsoleSceneController {
    private static final String __newline = "\n";
    private static final String CSS_FAINT_FOCUS_TRANSPARENT = "-fx-faint-focus-color: transparent;";
    private static final String CSS_FOCUS_TRANSPARENT = "-fx-focus-color: transparent;";
    private static final String CSS_FONT_SIZE = "-fx-font-size: %1$2s ;";
    private static final String CSS_TEXT_FILL = "-fx-text-fill: %1$2s ;";

    public byte[] input;
    private String displayBuffer; // Buffer for the display
    private FXTextFieldInputStream inputStream;

    private Logger logger = LoggerFactory
            .getLogger(ConsoleSceneController.class);
    private GUICore root; // Pointer back to the root

    @FXML
    private TextArea textDisplay;
    @FXML
    private TextField textInput;

    public ConsoleSceneController() {
    }

    /**
     * Appends a string to the displayBuffer then updates the textDisplay
     * 
     * @param input
     *            string to append
     */
    public void appendToDisplay(String input) {
        this.displayBuffer += input + __newline;
        this.textDisplay.appendText(input + __newline);
    }

    /**
     * Applies a DisplayControllerConfig to modify certain settings. Refer to
     * DisplayControllerConfig class for more details.
     * 
     * @param controllerConfig
     */
    public void applyConfig(DisplayControllerConfig controllerConfig) {
        applyToTextDisplay(controllerConfig.getGUITextDisplayConfig());
        applyToTextInput(controllerConfig.getGUITextInputConfig());

    }

    public InputStream getInputStream() {
        return this.inputStream;
    }

    /**
     * Is called by the main application to give a reference back to itself.
     * 
     * @param GUICore
     */
    public void setRoot(GUICore root) {
        this.root = root;

        // Get the root to provide the initial text display
        this.displayBuffer = this.root.getConsoleInitString();

        // Update displayed text
        this.textDisplay.setText(new String()); // Flushes the display
        this.textDisplay.appendText(displayBuffer); // Activates listener
    }

    private void applyToTextDisplay(GUITextDisplayConfig textDisplayConfig) {
        this.textDisplay.setStyle(String.format(CSS_FONT_SIZE,
                textDisplayConfig.getTextSize()));
        this.textDisplay.setStyle(String.format(CSS_TEXT_FILL,
                textDisplayConfig.getTextColour()));

    }

    private void applyToTextInput(GUITextInputConfig textInputConfig) {
        this.textInput.setStyle(String.format(CSS_FONT_SIZE,
                textInputConfig.getTextSize()));
        this.textInput.setStyle(String.format(CSS_TEXT_FILL,
                textInputConfig.getTextColour()));

    }

    @FXML
    private void initialize() {
        // Initialise text display
        this.textDisplay.setWrapText(false); // disable wrapping
        this.textDisplay.setEditable(false); // Disables editing
        this.textDisplay.setStyle(CSS_FOCUS_TRANSPARENT);
        this.textDisplay.setStyle(CSS_FAINT_FOCUS_TRANSPARENT);

        /*
         * Add a listener that auto-scrolls the display to the bottom whenever
         * there are new strings appended
         */
        this.textDisplay.textProperty().addListener(
                new ChangeListener<Object>() {
                    @Override
                    public void changed(ObservableValue<?> observable,
                            Object oldValue, Object newValue) {
                        textDisplay.setScrollTop(Double.MAX_VALUE);
                    }
                });

        // Initialise buffer to be empty string
        this.displayBuffer = "";
        this.textDisplay.appendText(this.displayBuffer);

        // Initialise text input
        this.textInput.setAlignment(Pos.TOP_LEFT); // Align top left
        this.textInput.setStyle(CSS_FOCUS_TRANSPARENT);
        this.textInput.setStyle(CSS_FAINT_FOCUS_TRANSPARENT);

        /*
         * Create an InputStream that specifically captures input from the
         * TextArea. A listener notifies the inputstream to unblock itself once
         * enter button is pressed
         */
        this.inputStream = new FXTextFieldInputStream(textInput);
        this.logger.info("InputStream Thread created, Init complete");
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\view\ConsoleSceneController.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\view\LocalResource.java
	 */

package w094j.ctrl8.display.gui.view;

/**
 * Class contains the list of filepaths (as String) to resources that the
 * application uses.
 */
public class LocalResource {
    public static final String ConsoleScene = "/ConsoleScene.fxml";
    public static final String RootLayout = "/RootLayout.fxml";

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\gui\view\LocalResource.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\GUIDisplay.java
	 */

package w094j.ctrl8.display;

import java.io.InputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import w094j.ctrl8.database.config.GUIDisplayConfig;
import w094j.ctrl8.display.gui.GUICore;
import w094j.ctrl8.exception.OutputExecuteException;
import w094j.ctrl8.message.MagicNumbersAndConstants;
import w094j.ctrl8.message.OuputExecuteMessage;
import w094j.ctrl8.pojo.Response;
import w094j.ctrl8.pojo.Task;

/**
 * Class implements Display using JavaFX framework which creates an application
 * for the user to interact with. The application window runs on a seperate
 * thread to prevent the main thread from freezing up due to the nature of
 * JavaFX. Instead, thread notifications are used to notify the main thread (who
 * holds GUIDisplay) when it is initialised and ready for interaction.
 *
 * <pre>
 * This implementation is incomplete and unstable.
 * </pre>
 */
@Deprecated
public class GUIDisplay extends Display {
    private GUICore guiCore;
    private Thread GUIThread;
    private Logger logger = LoggerFactory.getLogger(GUIDisplay.class);

    /**
     *
     */
    public GUIDisplay() {
        this.guiCore = new GUICore(new GUIDisplayConfig(),
                Thread.currentThread());
    }

    /**
     * @param config
     */
    public GUIDisplay(GUIDisplayConfig config) {
        if ((config == null) || !config.isValid()) {
            this.logger
                    .debug("Invalid or null config received! Reverting to defaults.");
            this.guiCore = new GUICore(new GUIDisplayConfig(),
                    Thread.currentThread());
        } else {
            this.guiCore = new GUICore(config, Thread.currentThread());
        }
        this.GUIThread = new Thread(this.guiCore);
        /*
         * Ensure that GUIThread is completely initialised before returning
         * constructor
         */
        synchronized (this.GUIThread) {
            this.GUIThread.start();
        }
    }

    @Override
    public InputStream getInputStream() {
        return this.guiCore.getInputStream();
    }

    @Override
    public void goodbye() {
        // TODO Not Implemented Yet

    }

    @Override
    public <T> T promptUser(Prompt<T> prompt) {
        // TODO Not Implemented Yet
        return null;
    }

    /*
     * XXX Buggy. Ideally the updateUI Function needs to notify the application
     * thread to update the UI while providing a shareable version of response
     * for the application thread to access. Current version does not work
     * because the main thread is tampering with JavaFX objects which throws
     * exceptions
     */
    @Override
    public void updateUI(Response res) {
        boolean allNull = true; // Initial assumption
        if (res.reply != null) {
            try {
                Thread.sleep(3000); // 1000 milliseconds is one second.
            } catch (InterruptedException ex) {
                Thread.currentThread().interrupt();
            }
            System.out.println(this.guiCore.getConsoleController());
            this.guiCore.getConsoleController().appendToDisplay(res.reply);
            allNull = false;
        }
        if (res.taskList != null) {
            try {
                this.outputTask(res.taskList);
            } catch (OutputExecuteException e) {
                this.logger.debug(e.getMessage());
            }
            allNull = false;
        }

        if (allNull) {
            this.logger
                    .debug("Respose object does not contain any useful information");
        }
    }

    @Override
    public void welcome() {
        // TODO Auto-generated method stub

    }

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\GUIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\CommandExecuteException.java
	 */


/*
 * Exception class thrown for any errors encountered in execution when Statement object calls .execute()
 */
public class CommandExecuteException extends Exception {
    // Parameterless constructor
    public CommandExecuteException() {
    }

    // Constructor that accepts a String message
    public CommandExecuteException(String message) {
        super(message);
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\CommandExecuteException.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\TaskOverwriteException.java
	 */


/*
 * Exception class thrown when an attempt to overwrite an existing task in a Database occurs
 * This is to ensure that we do not accidentally overwrite a Task with a Task delta resulting in loss of information
 */
public class TaskOverwriteException extends Exception {
    // Parameterless constructor
    public TaskOverwriteException() {
    }

    // Constructor that accepts a String message
    public TaskOverwriteException(String message) {
        super(message);
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\TaskOverwriteException.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\CommandExecutionMessage.java
	 */

package w094j.ctrl8.message;

/**
 * Class contains all messages used by Command-related functions of
 * Terminal.java
 */
public class CommandExecutionMessage {
    public static final String EXCEPTION_BAD_TASKID = "TaskID does not exist in TaskMap";
    public static final String EXCEPTION_IS_INCOMPLETE_TASK = "TaskType=INCOMPLETE";
    public static final String EXCEPTION_MISSING_TASK = "Database does not contain Task";
    public static final String EXCEPTION_NULL_TASK = "Task Object not initialised";
    public static final String EXCEPTION_UPDATE_TASK_MAP = "Update TaskMap Error";
    public static final String INVALID_INDEX = "Invalid Index!";
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\CommandExecutionMessage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\NormalMessage.java
	 */

    public static final String HELP_ADD_COMMAND_SYNTAX = "add ={<title>}";
    public static final String HELP_ALL = NormalMessage.HELP_HEADER
            + NormalMessage.HELP_ADD_COMMAND_SYNTAX + "\n"
            + NormalMessage.HELP_DELETE_COMMAND_SYNTAX + "\n"
            + NormalMessage.HELP_MODIFY_COMMAND_SYNTAX + "\n"
            + NormalMessage.HELP_VIEW_COMMAND_SYNTAX + "\n";
    public static final String HELP_DELETE_COMMAND_SYNTAX = "delete <query>";
    public static final String HELP_HEADER = "List of supported commands: \n";
    public static final String HELP_MODIFY_COMMAND_SYNTAX = "modify <query> ={<title>}..";

    public static final String HELP_VIEW_COMMAND_SYNTAX = "view";
    public static final String MODIFY_TASK_SUCCESSFUL = " modified successfully!";
    public static final String NO_FILEPATH_MESSAGE = "No filepath entered. Using default filepath.";
    public static final String NO_TASK_FOUND = "No Tasks found.";

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\NormalMessage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\Response.java
	 */

package w094j.ctrl8.pojo;

import java.util.ArrayList;

import w094j.ctrl8.data.AliasData;
import w094j.ctrl8.parse.statement.CommandType;

/**
 * Response object defines what a Display Interface expects to receive after a
 * user string processed internally for producing the appropriate feedback to
 * the user. It can contain any of these properties:
 *
 * <pre>
 * A String that contains useful feedback to the user
 * A list of tasks that are to be displayed as a table to the user
 * </pre>
 *
 * If a particular property is not part of a response, it should be defined as
 * NULL
 */
public class Response {
    public ArrayList<Actions> actions;
    public AliasData alias;
    /*
     * The list of properties(variables) that a response MAY contain
     */
    public String reply;
    public String[] TaskIdList;
    public Task[] taskList;
    private CommandType commandRan;
    private Exception exception;
    private boolean isContinueExecution;
    private boolean isError;

    /**
     * Initializes a response that signals that the Statement failed to execute.
     */
    public Response() {
        this.isError = true;
    }

    /**
     * Default constructor. Initializes all properties to be NULL
     */
    public Response(CommandType commandRan) {
        this.commandRan = commandRan;
        this.reply = null;
        this.taskList = null;
        this.alias = null;
        this.actions = null;
        this.TaskIdList = null;
        this.isContinueExecution = true;
    }

    /**
     * @return the commandRan
     */
    public CommandType getCommandRan() {
        return this.commandRan;
    }

    /**
     * @return the exception
     */
    public Exception getException() {
        return this.exception;
    }

    /**
     * @return the isContinueExecution
     */
    public boolean isContinueExecution() {
        return this.isContinueExecution;
    }

    /**
     * @param commandRan
     *            the commandRan to set
     */
    public void setCommandRan(CommandType commandRan) {
        this.commandRan = commandRan;
    }

    /**
     * @param isContinueExecution
     *            the isContinueExecution to set
     */
    public void setContinueExecution(boolean isContinueExecution) {
        this.isContinueExecution = isContinueExecution;
    }

    /**
     * @param exception
     *            the exception to set
     */
    public void setException(Exception exception) {
        this.exception = exception;
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\Response.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\ITaskManager.java
	 */

public interface ITaskManager {

    /**
     * <pre>
     * Part of CRUD: Create
     * </pre>
     *
     * Adds a task to data store. When poorly defined Task is used or execution
     * mischap occurs, CommandExecuteException is thrown
     *
     * @param task
     *            Task object. Expects a well defined Task, otherwise throws
     *            CommandExecuteException
     * @param statement
     * @throws DataException
     * @throws IOException
     * @throws GeneralSecurityException
     *             @
     */
    public Response add(Task task, Statement statement, boolean isUndo);

    /**
     * View all aliases in the database.
     */
    public Response alias(Statement statement);

    /**
     * adding of alias from user
     *
     * @param alias
     * @param value
     * @param statement
     * @throws DataException
     * @throws IOException
     * @throws GeneralSecurityException
     *             @
     */
    public Response aliasAdd(String alias, String value, Statement statement,
            boolean isUndo);

    /**
     * delete a alias
     *
     * @param query
     * @param statement
     * @throws DataException
     */
    public Response aliasDelete(String query, Statement statement,
            boolean isUndo) throws DataException;

    /**
     * <pre>
     * Part of CRUD: Delete
     * </pre>
     *
     * Deletes a task in the data store given the taskID that the object
     * contains. If the taskID does not currently exist in the data store, or
     * any failure in storage operation occurs, CommandExecuteException is
     * thrown.
     *
     * @param taskID
     *            key that represents the task object
     * @param statement
     * @throws CommandExecuteException
     * @throws DataException
     *             @
     */
    public Response delete(String taskID, Statement statement, boolean isUndo)
            throws CommandExecuteException, DataException;

    /**
     * Set the task's status to done
     *
     * @param query
     * @param statement
     * @throws CommandExecuteException
     * @throws DataException
     *             @
     */
    public Response done(String query, Statement statement, boolean isUndo)
            throws CommandExecuteException, DataException;

    /**
     * Stops the Terminal from continuing its REPL loop. Function is called when
     * an exit statement is executed. Performs a cleanup before terminating the
     * terminal See Issue #74 on github
     */
    public Response exit(Statement statement);

    /**
     * Generates information to assist the user in understanding the available
     * syntax and displays it.
     *
     * @param command
     */
    public Response help(CommandType command, Statement statement); // TODO add
// parameter to support help
// for
// specific
// commands

    /**
     * remove the specified history with index
     *
     * @param index
     */
    public Response historyClear(int parseInt, Statement statement);

    /**
     * undo the action with index in history
     *
     * @param index
     * @throws CommandExecuteException
     * @throws DataException
     *             @
     */
    public Response historyUndo(int parseInt, Statement statement)
            throws CommandExecuteException, DataException;

    /**
     * <pre>
     * Part of CRUD: Update
     * </pre>
     *
     * Modifies a task currently existing in the data store with new
     * information, using a query. A matching task is found using the query,
     * then the modify operation is performed. Existing fields are overwritten.
     * Bad query, poorly formed task, or failure in modification operation will
     * throw CommandExecuteException
     *
     * @param query
     *            String that contains what the user wants to search the data
     *            store with.
     * @param incompleteTask
     *            a Task that may not neccessarily have all its fields
     *            completed. Is used as an overwrite.
     * @param statement
     * @throws CommandExecuteException
     * @throws DataException
     *             @
     */
    public Response modify(String query, Task incompleteTask,
            Statement statement, boolean isUndo)
                    throws CommandExecuteException, DataException;

    /**
     * Saves the Tasks in the task manager,
     */
    public void save();

    /**
     * TODO
     *
     * @param query
     * @param task
     * @throws DataException
     */
    public Response search(String query, Statement statement)
            throws DataException;

    /**
     * <pre>
     * Part of CRUD: Read
     * </pre>
     *
     * Displays to the user, the list of Tasks that are in the data store. May
     * be an incomplete list if there are too many tasks.
     *
     * @throws CommandExecuteException
     */
    public Response view(Statement statement) throws CommandExecuteException;

    /**
     * view the history of actions
     *
     * @throws CommandExecuteException
     */
    public Response viewHistory(Statement statement)
            throws CommandExecuteException;

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\ITaskManager.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java
	 */


/**
 * Class encapsulates an object that acts as a driver for the program. It
 * accepts a config object and an object that implements the Display Interface
 * as arguments. It may interact with one or more Datastore to manage its I/O
 * operations. It parses user inputs and translates them into statements for
 * command objects to perform needed operations (e.g ADD operation)
 */
public class TaskManager implements ITaskManager {

    private static TaskManager instance;

    // Static constants
    private static Logger logger = LoggerFactory.getLogger(TaskManager.class);
    private static final int TASK_MAP_MINIMUM_SIZE = 0;

    private AliasData aliasData;
    // Storage object (External)
// private IDatabase database;
    private TaskData taskData;

    /**
     * Following Singleton pattern, All constructors are made private. Only way
     * to get an instance is through getInstance() and initInstance()
     */
    private TaskManager() {

    }

    /**
     * Constructor for terminal with a config object
     *
     * @param config
     *            Configuration information specifying how Terminal/Display is
     *            to be setup
     * @param aliasData
     * @param taskData
     * @param display
     * @param database
     */
    private TaskManager(TaskManagerConfig config, AliasData aliasData,
            TaskData taskData) {
        assertNotNull(config); // Should not be a null object
        this.aliasData = aliasData;
        this.taskData = taskData;
    }

    /**
     * Gets the current instance of the TaskManager.
     *
     * @return the current instance.
     */
    public static TaskManager getInstance() {
        if (instance == null) {
            throw new RuntimeException(
                    "Task Mananger must be initialized before retrieveing.");
        }
        return instance;
    }

    /**
     * Creates a Task Manager
     *
     * @param config
     * @param aliasData
     * @param taskData
     * @return return the Task manager.
     */
    public static TaskManager initInstance(TaskManagerConfig config,
            AliasData aliasData, TaskData taskData) {
        if (instance != null) {
            throw new RuntimeException(
                    "Cannot initialize Task Manager as it was initialized before.");
        } else {
            instance = new TaskManager(config, aliasData, taskData);
        }
        return instance;
    }

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java





