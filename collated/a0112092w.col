//@author: a0112092w



	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\data\TaskData.java
	 */

/**
 * This class contains all the task's data that are needed for task-related
 * operation
 */
public class TaskData {

    private static Logger logger = LoggerFactory.getLogger(TaskData.class);

    // Hash Map that stores every task and its history
    private HashMap<ObjectId, TaskState> taskStateMap;

    /**
     * Default constructor of TaskData
     */
    public TaskData() {
        this.taskStateMap = new HashMap<ObjectId, TaskState>();
    }

    /**
     * add a task for Lucene to search.
     *
     * @param indexWriter
     * @param title
     * @param description
     * @param id
     */
    private static void addDoc(IndexWriter indexWriter, String title,
            String description, ObjectId id) throws IOException {

        Document doc = new Document();
        doc.add(new TextField("title", title, Field.Store.YES));
        doc.add(new TextField("id", id.toString(), Field.Store.YES));
        // use a string field for isbn because we don't want it tokenized
        doc.add(new TextField("description", description == null ? ""
                : description, Field.Store.YES));
        indexWriter.addDocument(doc);
    }

    /**
     * Check if the taskId exist in the data structure.
     *
     * @param taskID
     * @return true when the data structure contains the taskID.
     */
    public boolean containsKey(String taskID) {
        return this.taskStateMap.containsKey(taskID);
    }

    /**
     * Deletes the History of index.
     *
     * @param index
     * @return the list of actions.
     */
    public Actions deleteHistory(int index) {
        ArrayList<Actions> actions = this.getActionsList();
        Actions actionToBeDel = actions.get(index - 1);

        ObjectId id = actionToBeDel.getTaskID();
        TaskState task = this.taskStateMap.get(id);
        if (task.remove(actionToBeDel)) {
            this.taskStateMap.remove(id);
        }
        return actionToBeDel;
    }

    /**
     * Returns the entry set.
     *
     * @return entrySet.
     */
    public Set<Entry<ObjectId, TaskState>> entrySet() {
        return this.taskStateMap.entrySet();
    }

    /**
     * Actions List of all the Tasks in chronological order.
     *
     * @return the array of actions.
     */
    public ArrayList<Actions> getActionsList() {
        ArrayList<Actions> actions = new ArrayList<Actions>();
        for (TaskState t : this.taskStateMap.values()) {
            for (int i = 0; i < t.getActionList().size(); i++) {
                actions.add(t.getActions(i));
            }
        }
        logger.debug("actionslist size " + actions.size());
        Collections.sort(actions);
        return actions;
    }

    /**
     * Get a particular task.
     *
     * @param taskId
     * @return task.
     */
    public Task getTask(ObjectId taskId) {
        return this.taskStateMap.get(taskId).getFinalTask();
    }

    /**
     * Return the taskList.
     *
     * @return task List
     */
    public Task[] getTaskList() {
        Task[] taskList = new Task[this.numOfTasks()];
        int i = 0;
        for (TaskState t : this.taskStateMap.values()) {
            Task task = t.getFinalTask();
            if (task != null) {
                taskList[i] = task;
                i++;
            }
        }
        Arrays.sort(taskList);
        return taskList;
    }

    /**
     * @return TaskState Map
     */
    public HashMap<ObjectId, TaskState> getTaskStateMap() {
        return this.taskStateMap;
    }

    /**
     * This is a function to check is a task exist in the task map
     *
     * @param query
     * @return boolean that true shows the task exist in the task map
     */
    public boolean isTaskExist(String query) {
        return this.taskStateMap.containsKey(query);
    }

    /**
     * @return number of tasks in the the tasks data structure.
     */
    public int numOfTasks() {
        int size = 0;
        for (TaskState t : this.taskStateMap.values()) {
            if (t.getFinalTask() != null) {
                size++;
            }
        }
        return size;
    }

    /**
     * Removes a task from the data structure,
     *
     * @param id
     *            to use to be removed.
     * @param statement
     *            the statement that executed it.
     * @return the removed task.
     */
    public Task remove(ObjectId id, Statement statement) {
        Task task = this.taskStateMap.get(id).getFinalTask();
        this.taskStateMap.get(id).setFinalTask(null);
        this.taskStateMap.get(id).addActions(new Actions(statement, id));
        return task;
    }

    /**
     * Search all the task that are add into lucene with a query return an array
     * of string that contains all the task's Id. With reference from
     * http://www.lucenetutorial.com/code/HelloLucene.java.
     *
     * @param query
     *            search query.
     * @return the array of tasks.
     * @throws DataException
     *             when there is a problem with the query
     */
    public Task[] search(String query) throws DataException {
        Task[] taskIdList = null;
        try {
            // 0. Specify the analyzer for tokenizing text.
            // The same analyzer should be used for indexing and searching
            Analyzer analyzer = new SimpleAnalyzer();

            // 1. create the index
            Directory index = new RAMDirectory();

            IndexWriterConfig config = new IndexWriterConfig(analyzer);

            IndexWriter w = new IndexWriter(index, config);
            for (ObjectId key : this.getTaskStateMap().keySet()) {
                Task t = this.getTask(key);
                if (t != null) {
                    addDoc(w, t.getTitle(), t.getDescription(), t.getId());
                }
            }
            w.close();

            // 2. query
            if (query.length() < 0) {
                throw new DataException("Query must exist.");
            }

            // the "title" arg specifies the default field to use
            // when no field is explicitly specified in the query.
            Query q = new QueryParser("title", analyzer).parse(query);

            // 3. search
            int hitsPerPage = 10;
            IndexReader reader = DirectoryReader.open(index);
            IndexSearcher searcher = new IndexSearcher(reader);
            TopScoreDocCollector collector = TopScoreDocCollector
                    .create(hitsPerPage);
            searcher.search(q, collector);
            ScoreDoc[] hits = collector.topDocs().scoreDocs;

            // 4. display results
            if (hits.length > 0) {
                taskIdList = new Task[hits.length];

                logger.debug("Found:" + hits.length + " hits.");
                for (int i = 0; i < hits.length; ++i) {
                    int docId = hits[i].doc;

                    Document d = searcher.doc(docId);
                    ObjectId t = new ObjectId(d.get("id"));

                    taskIdList[i] = this.getTask(t);
                    logger.debug("Task#" + i + "="
                            + new Gson().toJson(taskIdList[i]));
                }
            } else {
                logger.debug("No results.");
            }

            // reader can only be closed when there
            // is no need to access the documents any more.
            reader.close();
        } catch (DataException e) {
            throw e;
        } catch (IOException | ParseException e) {
            throw new DataException(
                    "There was an unexpected error, please report this to our techical team.");
        }
        Arrays.sort(taskIdList);
        return taskIdList;
    }

    /**
     * @param taskStateMap
     */
    public void setTaskStateMap(HashMap<ObjectId, TaskState> taskStateMap) {
        this.taskStateMap = taskStateMap;
    }

    /**
     * @param index
     * @param taskManager
     * @throws CommandExecuteException
     * @throws DataException
     */
    public void undoHistory(int index, ITaskManager taskManager)
            throws CommandExecuteException, DataException {
        ArrayList<Actions> actions = this.getActionsList();
        if (index > actions.size()) {
            throw new CommandExecuteException(
                    CommandExecutionMessage.INVALID_INDEX);
        }
        Actions action = actions.get(index - 1);
        ObjectId id = action.getTaskID();
        action.getID();
        ArrayList<Actions> taskActions = this.taskStateMap.get(id)
                .getActionList();
        this.taskStateMap.get(id).clearActionList();
        this.taskStateMap.get(id).setFinalTask(
                this.taskStateMap.get(id).getInitTask());
        if (this.taskStateMap.get(id).getInitTask() == null) {
            logger.debug("init task is null");
        }
        int i = 0;
        for (; i < taskActions.size(); i++) {
            if (action.equals(taskActions.get(i))) {
                logger.debug("action same: "
                        + action.equals(taskActions.get(i)));
                break;
            }
            logger.debug("action name: "
                    + taskActions.get(i).getStatement().getCommand()
                    + " "
                    + taskActions.get(i).getStatement()
                    .getStatementArgumentsOnly());
            Statement statement = taskActions.get(i).getStatement();
            statement.execute(taskManager, true);
        }
// for(int j=i;j<taskActions.size();j++)
// {
// task.remove(j);
// }
    }

    /**
     * Adds a task to the taskMap as well as removing an older entry. To be used
     * together with modify() command. When taskTitle is modified, its key in
     * the hashmap also changes.
     *
     * @param id
     * @param task
     * @param statement
     * @param isUndo
     */
    public void updateTaskMap(ObjectId id, Task task, Statement statement,
            Boolean isUndo) {
        // Check for null params
        assert (id != null);
        assert (task != null);
        // Task should not be incomplete (not a Task delta)
        assert (task.getTaskType() != Task.TaskType.INCOMPLETE);

        if (this.taskStateMap.containsKey(id)) {
            if (!(isUndo)) {
                this.taskStateMap.get(id)
                .addActions(new Actions(statement, id));
                logger.debug("isUndo = false");
            }
            this.taskStateMap.get(id).setFinalTask(task);
            logger.debug("TaskMap: Replace entry with key " + task.getTitle()
                    + " with " + new Gson().toJson(task));
        } else {
            this.taskStateMap.put(task.getId(), new TaskState(task, statement));
            logger.debug("TaskMap: Add new entry with key " + task.getTitle()
                    + " with " + new Gson().toJson(task));
        }
    }

    /**
     * Adds a task to the taskMap using taskTitle as the key. If key already
     * exists, it overwrites the entry.
     *
     * @param task
     * @param statement
     * @param isUndo
     *            is this executing for a undo operation.
     */
    public void updateTaskMap(Task task, Statement statement, boolean isUndo) {

        // Check for null params
        assert (task != null);
        // Task should not be incomplete (not a Task delta)
        assert (task.getTaskType() != Task.TaskType.INCOMPLETE);
        if (this.taskStateMap.containsKey(task.getId())) {
            this.taskStateMap.replace(task.getId(), new TaskState(task,
                    statement));
            this.taskStateMap.get(task.getId()).setFinalTask(task);
            logger.debug("TaskMap: Replace entry with key " + task.getTitle()
                    + " with " + new Gson().toJson(task));
        } else {

            this.taskStateMap.put(task.getId(), new TaskState(task, statement));
            this.taskStateMap.get(task.getId()).setFinalTask(task);
            logger.debug("TaskMap: adding new entry with key "
                    + task.getTitle() + " with " + new Gson().toJson(task));
        }
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\data\TaskData.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\CLIDisplayConfig.java
	 */

/**
 * Configurations for the Command Line Display component.
 */
public class CLIDisplayConfig implements IStorableElement {

    private static String APP_NAME_DEFAULT = "Ctrl-8";
    private static String DATE_FORMAT_DEFAULT = "dd-MMM-yy hh:mm a";
    private static String GOODBYE_MESSAGE_DEFAULT = "Thank you for using %1$s";
    private static String PROMPT_DEFAULT = "%1$s > ";
    private static String WELCOME_MESSAGE_DEFAULT = "Welcome for using %1$s!";

    private String appName;
    private String dateFormat;
    private String goodbyeMessage;
    private String promptDefault;
    private String welcomeMessage;

    /**
     * @return the appName
     */
    public String getAppName() {
        if (this.appName == null) {
            return APP_NAME_DEFAULT;
        } else {
            return this.appName;
        }
    }

    /**
     * @return the dateFormat
     */
    public String getDateFormat() {
        if (this.dateFormat == null) {
            return DATE_FORMAT_DEFAULT;
        } else {
            return this.dateFormat;
        }
    }

    /**
     * @return the goodbyeMessage
     */
    public String getGoodbyeMessage() {
        if (this.goodbyeMessage == null) {
            return GOODBYE_MESSAGE_DEFAULT;
        } else {
            return this.goodbyeMessage;
        }
    }

    /**
     * @return the promptDefault
     */
    public String getPromptDefault() {
        if (this.promptDefault == null) {
            return PROMPT_DEFAULT;
        } else {
            return this.promptDefault;
        }
    }

    /**
     * @return the welcomeMessage
     */
    public String getWelcomeMessage() {
        if (this.welcomeMessage == null) {
            return WELCOME_MESSAGE_DEFAULT;
        } else {
            return this.welcomeMessage;
        }
    }

    @Override
    public boolean isValid() {
        if (this.dateFormat != null) {
            try {
                new SimpleDateFormat(this.dateFormat);
            } catch (IllegalArgumentException iae) {
                return false;
            }
        }
        return true;
    }

    /**
     * @param appName
     *            the appName to set
     */
    public void setAppName(String appName) {
        this.appName = appName;
    }

    /**
     * @param dateFormat
     *            the dateFormat to set
     */
    public void setDateFormat(String dateFormat) {
        this.dateFormat = dateFormat;
    }

    /**
     * @param goodbyeMessage
     *            the goodbyeMessage to set
     */
    public void setGoodbyeMessage(String goodbyeMessage) {
        this.goodbyeMessage = goodbyeMessage;
    }

    /**
     * @param promptDefault
     *            the promptDefault to set
     */
    public void setPromptDefault(String promptDefault) {
        this.promptDefault = promptDefault;
    }

    /**
     * @param welcomeMessage
     *            the welcomeMessage to set
     */
    public void setWelcomeMessage(String welcomeMessage) {
        this.welcomeMessage = welcomeMessage;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\CLIDisplayConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DisplayConfig.java
	 */

/**
 * The config of the display.
 */
public class DisplayConfig implements IStorableElement {

    private static final boolean IS_GUI_DEFAULT = false;

    private CLIDisplayConfig CLI;
    private GUIDisplayConfig GUI;
    private Boolean isGUI;

    /**
     * Display Config
     */
    public DisplayConfig() {
        this.GUI = new GUIDisplayConfig();
        this.CLI = new CLIDisplayConfig();
    }

    /**
     * @return the cLI
     */
    public CLIDisplayConfig getCLI() {
        return this.CLI;
    }

    /**
     * @return the gUI
     */
    public GUIDisplayConfig getGUI() {
        return this.GUI;
    }

    /**
     * @return the isGUI
     */
    public boolean isGUI() {
        if (this.isGUI == null) {
            return IS_GUI_DEFAULT;
        } else {
            return this.isGUI;
        }
    }

    @Override
    public boolean isValid() {
        if (this.isGUI()) {
            return ((this.GUI != null) && this.GUI.isValid());
        } else {
            return ((this.CLI != null) && this.CLI.isValid());
        }
    }

    /**
     * @param cLI
     *            the cLI to set
     */
    public void setCLI(CLIDisplayConfig cLI) {
        this.CLI = cLI;
    }

    /**
     * @param isGUI
     *            the isGUI to set
     */
    public void setGUI(boolean isGUI) {
        this.isGUI = isGUI;
    }

    /**
     * @param gUI
     *            the gUI to set
     */
    public void setGUI(GUIDisplayConfig gUI) {
        this.GUI = gUI;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\DisplayConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\TaskManagerConfig.java
	 */


/**
 * The config of the task manager It is currently a stub
 */
public class TaskManagerConfig implements IStorableElement {

    @Override
    public boolean isValid() {
        // TODO Auto-generated method stub
        return true;
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\TaskManagerConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\TerminalConfig.java
	 */


/**
 * The config of the terminal It is a stub currently
 */
public class TerminalConfig implements IStorableElement {

    @Override
    public boolean isValid() {
        return true;
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\database\config\TerminalConfig.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java
	 */

public class CLIDisplay extends Display {

    private static final String BETWEEN_SEPERATOR = " | ";

    private static final String DEADLINED_TASK_NAME = "Tasks with Deadline";

    private static final String END_SEPERATOR = " |";
    private static final String FLOATING_TASK_NAME = "Tasks";
    private static final char LINE_COMPONENT = '-';
    private static Logger logger = LoggerFactory.getLogger(CLIDisplay.class);
    private static final String START_SEPERATOR = "| ";
    private static final String TIMED_TASK_NAME = "Events";
    private static final char TITLE_LINE_COMPONENT = '=';
    private CLIDisplayConfig config;

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java
	 */

    /**
     * Public constructor for a CLI Display
     */
    CLIDisplay(CLIDisplayConfig cliDisplayConfig) {
        this.config = cliDisplayConfig;
    }

    /**
     * Returns n number of lineComponent.
     *
     * @param n
     * @param lineComponent
     */
    private static String getDashes(int n, Character lineComponent) {
        StringBuilder sb = new StringBuilder();
        for (int x = 0; x < n; x++) {
            sb.append(lineComponent);
        }
        return sb.toString();
    }

    /**
     * Print n number of lineComponent
     *
     * @param n
     * @param lineComponent
     */
    private static void printDashes(int n, Character lineComponent) {
        System.out.println(getDashes(n, lineComponent));
    }

    /**
     * This method is used to print a table with format of following the format
     * of right justified table x xxx yyy y zz zz
     *
     * @param title
     * @param table
     */
    private static void printTable(String title, String[][] table) {

        // Find out what the maximum number of columns is in any row
        int maxColumns = 0;
        for (String[] element : table) {
            maxColumns = Math.max(element.length, maxColumns);
        }

        // Find the maximum length of a string in each column
        int[] lengths = new int[maxColumns];
        for (String[] element : table) {
            for (int j = 0; j < element.length; j++) {
                lengths[j] = Math.max(element[j].length(), lengths[j]);
            }
        }

        // print the title bar
        int boundaryOffset = (START_SEPERATOR.length() + END_SEPERATOR.length());
        int sumLength = boundaryOffset - BETWEEN_SEPERATOR.length();
        for (int eaLength : lengths) {
            sumLength += eaLength + BETWEEN_SEPERATOR.length();
        }
        printDashes(sumLength, TITLE_LINE_COMPONENT);
        int leftOffset = (((sumLength + title.length()) / 2) - START_SEPERATOR
                .length());
        int rightOffset = sumLength - leftOffset - END_SEPERATOR.length();
        System.out.println(START_SEPERATOR
                + String.format("%" + leftOffset + "s%" + rightOffset + "s",
                        title, END_SEPERATOR));
        printDashes(sumLength, TITLE_LINE_COMPONENT);

        // Generate a format string for each column
        String[] formats = new String[lengths.length];
        for (int i = 0; i < lengths.length; i++) {
            formats[i] = "%1$"
                    + lengths[i]
                            + "s"
                            + ((i + 1) == lengths.length ? END_SEPERATOR + "\n"
                                    : BETWEEN_SEPERATOR);
        }

        // Print 'em out
        StringBuilder sb = new StringBuilder();
        try (Formatter formatter = new Formatter(sb)) {

            for (int x = 0; x < table.length; x++) {
                String[] element = table[x];
                sb.append(START_SEPERATOR);
                for (int j = 0; j < element.length; j++) {
                    formatter.format(formats[j], element[j]);
                }
                if (x == 0) {
                    sb.append(getDashes(sumLength, LINE_COMPONENT));
                    sb.append("\n");
                }
            }
            System.out.print(sb.toString());
            printDashes(sumLength, LINE_COMPONENT);
        }
    }

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java
	 */

    @Override
    public InputStream getInputStream() {
        return System.in;
    }

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java
	 */

        System.out.println(message);
    }

    /**
     * This method is used to output the task for the user in certain format.
     *
     * @param title
     * @param taskList
     * @param taskType
     * @throws OutputExecuteException
     */
    public void outputTask(String title, Task[] taskList, TaskType taskType)
            throws OutputExecuteException {

        System.out.println();

        boolean[] isActiveColumn = new boolean[MagicNumbersAndConstants.NUMBER_TASK_PROPERTIES];

        for (int x = 0; x < MagicNumbersAndConstants.NUMBER_TASK_PROPERTIES; x++) {

            isActiveColumn[x] = false;

            for (Task eaTask : taskList) {
                switch (x) {
                    case 0 :
                        if (eaTask.getTitle() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 1 :
                        if (eaTask.getCategory() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 2 :
                        if (eaTask.getDescription() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 3 :
                        if (eaTask.getStartDate() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 4 :
                        if (eaTask.getEndDate() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 5 :
                        if (eaTask.getLocation() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 6 :
                        if (eaTask.getPriority() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 7 :
                        if (eaTask.getReminder() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                    case 8 :
                        if (eaTask.getStatus() != null) {
                            isActiveColumn[x] = true;
                            break;
                        }
                        break;
                }
            }

        }

        int activeColumnSize = 0;
        for (boolean element : isActiveColumn) {
            if (element) {
                activeColumnSize++;
            }
        }

        String[][] table = this.initTable(taskList.length + 1, isActiveColumn,
                activeColumnSize, taskType);
        int iteration = taskList.length + 1;
        DateFormat df = new SimpleDateFormat(this.config.getDateFormat());
        table = this.initNullTaskTable(table, 1, activeColumnSize);

        for (int i = 1; i < iteration; i++) {
            // task should be not null
            if (taskList[i - 1] == null) {
                throw new OutputExecuteException(
                        OuputExecuteMessage.EXCEPTION_NULL_TASK);
            }

            int index = 0;
            for (int x = 0; x < isActiveColumn.length; x++) {
                if (isActiveColumn[x]) {
                    switch (x) {
                        case 0 :
                            if (taskList[i - 1].getTitle() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = taskList[i - 1].getTitle();
                            }
                            break;
                        case 1 :
                            if (taskList[i - 1].getCategory() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = taskList[i - 1].getCategory();
                            }
                            break;
                        case 2 :
                            if (taskList[i - 1].getDescription() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = taskList[i - 1]
                                        .getDescription();
                            }
                            break;
                        case 3 :
                            if (taskList[i - 1].getStartDate() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = df.format(taskList[i - 1]
                                        .getStartDate());
                            }
                            break;
                        case 4 :
                            if (taskList[i - 1].getEndDate() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = df.format(taskList[i - 1]
                                        .getEndDate());
                            }
                            break;
                        case 5 :
                            if (taskList[i - 1].getLocation() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = taskList[i - 1].getLocation();
                            }
                            break;
                        case 6 :
                            if (taskList[i - 1].getPriority() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = String
                                        .valueOf(taskList[i - 1].getPriority());
                            }
                            break;
                        case 7 :
                            if (taskList[i - 1].getReminder() == null) {
                                table[i][index] = "-";
                            } else {
                                table[i][index] = df.format(taskList[i - 1]
                                        .getReminder());
                            }
                            break;
                        case 8 :
                            if (taskList[i - 1].getStatus()) {
                                table[i][index] = "Yes";
                            } else {
                                table[i][index] = "-";
                            }
                            break;
                    }
                    index++;
                }
            }

        }
        printTable(title, table);
    }

    @Override
    public <T> T promptUser(Prompt<T> prompt) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public void updateUI(Response res) {

        logger.debug("Updating Response(" + new Gson().toJson(res) + ")");

        if (res.getCommandRan() == null) {
            System.out.println(res.getException().getMessage());
        } else {

            if (res.reply != null) {
                this.outputMessage(res.reply);
            }
            if (res.taskList != null) {

                List<Task> floatingTasks = new ArrayList<>();
                List<Task> timedTasks = new ArrayList<>();
                List<Task> deadlinedTasks = new ArrayList<>();

                for (Task eaTask : res.taskList) {
                    switch (eaTask.getTaskType()) {
                        case DEADLINE :
                            deadlinedTasks.add(eaTask);
                            break;
                        case FLOATING :
                            floatingTasks.add(eaTask);
                            break;
                        case TIMED :
                            timedTasks.add(eaTask);
                            break;
                        default :
                            // Should never be an incomplete task
                            assert (false);
                            break;
                    }
                }

                try {
                    if (floatingTasks.size() > 0) {
                        this.outputTask(FLOATING_TASK_NAME, floatingTasks
                                .toArray(new Task[floatingTasks.size()]),
                                TaskType.FLOATING);
                        System.out.println();
                    }
                    if (deadlinedTasks.size() > 0) {
                        this.outputTask(DEADLINED_TASK_NAME, deadlinedTasks
                                .toArray(new Task[deadlinedTasks.size()]),
                                TaskType.DEADLINE);
                        System.out.println();
                    }
                    if (timedTasks.size() > 0) {
                        this.outputTask(
                                TIMED_TASK_NAME,
                                timedTasks.toArray(new Task[timedTasks.size()]),
                                TaskType.TIMED);
                    }
                } catch (OutputExecuteException e) {
                    e.printStackTrace();
                }

            }

            if (res.alias != null) {
                this.outputAliases(res.alias);
            }
            if (res.actions != null) {
                this.outputActions(res.actions);
            }
        }

        if (!((res.getCommandRan() != null) && !res.isContinueExecution())) {

            System.out.print(String.format(this.config.getPromptDefault(),
                    this.config.getAppName()));
        }

    }

    @Override
    public void welcome() {
        System.out.println(String.format(this.config.getWelcomeMessage(),
                this.config.getAppName()));
        System.out.print(String.format(this.config.getPromptDefault(),
                this.config.getAppName()));
    }

    private String[][] initNullTaskTable(String[][] table, int taskNumber,
            int activeColumnSize) {
        int i = taskNumber;

        for (int x = 0; x < activeColumnSize; x++) {
            table[i][x] = "-";
        }

        return table;
    }

    // initialize the table with adding the first row for each of the task's
// properties
    private String[][] initTable(int taskNumber, boolean[] isActiveColumn,
            int activeColumnSize, TaskType taskType) {
        String[][] table = new String[taskNumber][activeColumnSize];
        int index = 0;
        for (int x = 0; x < isActiveColumn.length; x++) {
            if (isActiveColumn[x]) {
                switch (x) {
                    case 0 :
                        table[0][index] = "Title";
                        index++;
                        break;
                    case 1 :
                        table[0][index] = "Category";
                        index++;
                        break;
                    case 2 :
                        table[0][index] = "Description";
                        index++;
                        break;
                    case 3 :
                        table[0][index] = "From";
                        index++;
                        break;
                    case 4 :
                        if (taskType.equals(TaskType.DEADLINE)) {
                            table[0][index] = "Due";
                        } else {
                            table[0][index] = "To";
                        }
                        index++;
                        break;
                    case 5 :
                        table[0][index] = "Location";
                        index++;
                        break;
                    case 6 :
                        table[0][index] = "Priority";
                        index++;
                        break;
                    case 7 :
                        table[0][index] = "Reminder";
                        index++;
                        break;
                    case 8 :
                        table[0][index] = "Done";
                        index++;
                        break;
                }
            }
        }

        return table;
    }

    /**
     * Output the actions to user in appropiate way
     *
     * @param actions
     */
    private void outputActions(ArrayList<Actions> actions) {
        if (actions.size() == 0) {
            System.out.println("No actions found");
        }
        for (int i = 0; i < actions.size(); i++) {
            Statement statement = actions.get(i).getStatement();
            System.out.print(i + 1 + ". Command:");
            System.out.print(statement.getCommand().toString());
            System.out.print(" String:");
            System.out.println(statement.getStatementArgumentsOnly());
        }

    }

    /**
     * Output the alias data to user in appropiate way
     *
     * @param alias
     */
    private void outputAliases(AliasData alias) {
        Map<String, String> aliases = alias.getAliasMap();
        if (aliases.size() == 0) {
            System.out.println(NormalMessage.ALIAS_MAP_EMPTY);
        }
        for (int i = 0; i < aliases.size();) {
            for (String key : aliases.keySet()) {
                String value = aliases.get(key);
                System.out.print(i + 1 + ". Alias: " + key);
                System.out.println(" String: " + value);
                i++;
            }
        }
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\display\CLIDisplay.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\MissingTaskException.java
	 */

/**
 * Exception class thrown when a task is not found on the taskMap This is to
 * ensure that we do not accidentally modify other task or add a new task to the
 * taskMap
 */
public class MissingTaskException extends Exception {
    // Parameterless constructor

    /**
     *
     */
    private static final long serialVersionUID = 1L;

    /**
     *
     */
    public MissingTaskException() {
    }

    // Constructor that accepts a String message
    /**
     * @param message
     */
    public MissingTaskException(String message) {
        super(message);
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\exception\MissingTaskException.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\ErrorMessage.java
	 */

    public static final String TASK_KEY_ALREADY_EXISTS = "Error: Task key already exists!";
    public static final String TASK_KEY_DOES_NOT_EXIST = "Error: Task key does not exist!";

}
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\ErrorMessage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\MagicNumbersAndConstants.java
	 */

package w094j.ctrl8.message;

/**
 * This class stores all the magic numbers and String constants that will use by
 * other classes
 */
public class MagicNumbersAndConstants {
    // number of task's properties such as title, description etc.
    public static int NUMBER_TASK_PROPERTIES = 9;
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\MagicNumbersAndConstants.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\NormalMessage.java
	 */

/**
 * Class encapsulates all information that is pulled and/or pushed from an
 * external file. Examples include interacting with a local file. Or dumping
 * statement history into an output file. TODO: Cater for Google integration
 */

public class NormalMessage {
    public static final String ADD_TASK_SUCCESSFUL = " added successfully!";
    public static final String APP_NAME = "Ctrl-8";
    public static final String DELETE_TASK_SUCCESSFUL = " deleted successfully!";
    public static final String DELETED_TASK_HISTORY = "History of Deleted Task: ";
    public static final String DISPLAY_NEXT_COMMAND_REQUEST = "Next command: ";
    public static final String EXIT_COMMAND = "Thank you for using " + APP_NAME;

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\NormalMessage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\NormalMessage.java
	 */

    public static final String START_MESSAGE = "Starting Ctrl-8...";
    public static final String WELCOME_MESSAGE = "Welcome for using Ctrl-8!";
    public static final String DONE_TASK_SUCCESSFUL = " is done!";
    public static final String NO_HISTORY_FOUND = "No History Found";
    public static final String HISTORY_CLEAR_SUCCESSFUL = "The following action history is deleted successfully!";
    public static final String ALIAS_MAP_EMPTY = "There is no alias.";
    public static final String ADD_ALIAS_SUCCESSFUL = " is successfully alias to ";
    public static final String ALIAS_DELETE_SUCCESSFUL = "The following alias is deleted successfully!";
    public static final String HISTORY_INDEX_OUT_OF_BOUND = "History index out of bound";
    public static final String UNDO_ACTION_SUCCESSFUL = "Action is undo successfully";
    public static final String CHOOSE_FROM_LIST = "Please type in the index of task you want to choose to ";
    public static final String MODIFIED = "modified.";
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\message\NormalMessage.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\Actions.java
	 */

/**
 * This class is the wrapper for the statement that executed and the task that
 * related to it.
 */
public class Actions implements Comparable<Actions> {
    private ObjectId id;
    private Statement statement;
    private ObjectId taskID;

    /**
     * Creates a new actions with same statement and id with action
     *
     * @param action
     */
    public Actions(Actions action) {
        this.statement = action.getStatement();
        this.id = action.getID();
        this.setTaskID(action.getTaskID());
    }

    /**
     * @param statement
     * @param taskID
     */
    public Actions(Statement statement, ObjectId taskID) {
        this.statement = statement;
        this.id = new ObjectId();
        this.setTaskID(taskID);
    }

    @Override
    public int compareTo(final Actions action) {
        return this.id.compareTo(action.getID());
    }

    /**
     * Return the object id of this action
     *
     * @return id
     */
    public ObjectId getID() {
        return this.id;
    }

    /**
     * Return the statement that this action performs
     *
     * @return statement
     */
    public Statement getStatement() {
        return this.statement;
    }

    /**
     * @return the taskID
     */
    public ObjectId getTaskID() {
        return taskID;
    }

    /**
     * @param taskID the taskID to set
     */
    public void setTaskID(ObjectId taskID) {
        this.taskID = taskID;
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\Actions.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\TaskState.java
	 */


public class TaskState {
    // initial state of task. Default : null
    private Task initTask;
    // current/final state of task
    private Task finalTask;
    // the list of action that performs to the task
    private ArrayList<Actions> actionsList;
    
    

    /** Constructor that creates a TaskState with a new task and a statement
     * @param task
     * @param statement
     */
    public TaskState(Task task, Statement statement) {
        this.initTask = null;
        this.finalTask = task;
        this.actionsList = new ArrayList<Actions>();
        if(statement != null){
            this.actionsList.add(new Actions(statement, task.getId()));
        }
    }
    
    
    /** Get the initial state of task 
     * @return initial task
     */
    public Task getInitTask(){
        return this.initTask;
    }
    

    /**  Get the final state of task 
     * 
     * @return final task
     */
    public Task getFinalTask(){
        return this.finalTask;
    }
    
    /** Get the list of action that performs to this task 
     * @return action list
     */
    public ArrayList<Actions> getActionList(){
        return this.actionsList;
    }
    
    /** Set the final task state of this task to task
     * @param task
     */
    public void setFinalTask(Task task){
        this.finalTask = task;
    }
    

    /** Set the initial task state of this task to task
     * @param task
     */
    public void setInitTask(Task task){
        this.initTask = task;
    }
    

    /** Get the action in the action list with its index number in arraylist 
     * @param index
     * @return actions
     */
    public Actions getActions(int index){
        return this.actionsList.get(index);
    }
    

    /** Add an action to current actions list
     * @param action
     */
    public void addActions(Actions action){
        this.actionsList.add(action); 
    }

    /** Remove the action that has the same object id with actionToBeDel in the action list.
     *  Return true if the actions list is empty after the remover.
     * @param actionToBeDel
     * @return isEmpty
     */
    public boolean remove(Actions actionToBeDel) {
        boolean isHistoryEmpty = false;

        for(int i=0 ; i < this.actionsList.size(); i++){
            if (actionToBeDel.getID() == this.actionsList.get(i).getID()){
                this.actionsList.remove(i);
                break;
            }
        }
        
        if(this.actionsList.isEmpty() && this.finalTask == null){
            isHistoryEmpty = true;
        }
        
        return isHistoryEmpty;
    }

    /** Clear the action list
     * 
     */
    public void clearActionList() {

        this.actionsList = new ArrayList<Actions>();
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\pojo\TaskState.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java
	 */

    @Override
    public Response add(Task task, Statement statement, boolean isUndo) {

        Response res = new Response(statement.getCommand());

        // Task object should not be null
        assert (task != null);
        // Make sure we are not adding an Incomplete task to database
        assert (task.getTaskType() != TaskType.INCOMPLETE);

        logger.debug("in add task: " + task.getTitle());
        logger.debug("in add " + statement.getCommand() + " "
                + statement.getStatementArgumentsOnly());

        boolean isOverlapWarning = false;
        if ((task.getStartDate() != null) && (task.getEndDate() != null)
                && (this.taskData.getTaskList().length > 0)) {

            DateIntervalTree intervalTree = new DateIntervalTree(
                    this.taskData.getTaskList());

            if (intervalTree.isOverlap(task)) {
                isOverlapWarning = true;
            }
        }

        // Update Taskmap
        this.taskData.updateTaskMap(task, statement, isUndo);

        // Informs user that his add statement is successful
        if (isUndo == false) {
            res.reply = (isOverlapWarning ? "Warning, there is a clash in timings.\n"
                    : "")
                    + task.getTitle() + NormalMessage.ADD_TASK_SUCCESSFUL;
        }
        return res;
    }

    /**
     * Display all aliases to user
     */
    @Override
    public Response alias(Statement statement) {
        Response res = new Response(statement.getCommand());
        logger.debug("in alias taskmanager");
        if (this.aliasData.isEmpty()) {
            res.reply = NormalMessage.ALIAS_MAP_EMPTY;
        } else {
            logger.info("alias is passed to response");
            res.alias = this.aliasData;
        }
        return res;

    }

    @Override
    public Response aliasAdd(String alias, String value, Statement statement,
            boolean isUndo) {

        Response res = new Response(statement.getCommand());

        // add the alias to aliasData
        this.aliasData.addAlias(alias, value);

        // print add alias to user if this action is not undo
        if (isUndo == false) {
            res.reply = alias + NormalMessage.ADD_ALIAS_SUCCESSFUL + value;
        }
        return res;
    }

    /**
     * Delete an alias from current database with the alias string query, alias
     * value
     *
     * @throws DataException
     */
    @Override
    public Response aliasDelete(String query, Statement statement,
            boolean isUndo) throws DataException {

        Response res = new Response(statement.getCommand());

        // creates an alias data to be display to user
        String value = this.aliasData.toValue(query);
        AliasData deleted = new AliasData();
        deleted.addAlias(query, value);

        // delete the alias
        this.aliasData.deleteAlias(query);

        // display to user
        if (isUndo == false) {
            res.reply = NormalMessage.ALIAS_DELETE_SUCCESSFUL;
            res.alias = deleted;
        }

        return res;
    }

    /**
     * Delete an task from current database with a string query
     *
     * @param query
     * @param statement
     * @param isUndo
     * @throws CommandExecuteException
     * @throws DataException
     */
    @Override
    public Response delete(String query, Statement statement, boolean isUndo)
            throws CommandExecuteException, DataException {
        Task task = null;
        Response res = new Response(statement.getCommand());
        // search the task with the string query
        Task[] taskIdList = this.taskData.search(query);
        if (taskIdList == null) {
            throw new CommandExecuteException(
                    CommandExecutionMessage.EXCEPTION_MISSING_TASK);
        }
        /* Check if key exists in taskStateMap */
        if (taskIdList.length > 0) {
            // only 1 result from searching
            if (taskIdList.length == 1) {
                task = this.taskData.remove(taskIdList[0].getId(), statement);
            } else {
                int index = this
                        .chooseIndex(taskIdList, NormalMessage.MODIFIED);
                task = this.taskData.remove(taskIdList[index].getId(),
                        statement);
            }

            logger.debug("task removed successfully");

        } else {
            logger.debug("In delete cant find");
            logger.debug("in delete " + this.taskData.numOfTasks());
            throw new CommandExecuteException(
                    CommandExecutionMessage.EXCEPTION_BAD_TASKID);
        }
        // if action is not undo, shows the user delete task succesful
        if (isUndo == false) {
            res.reply = task.getTitle() + NormalMessage.DELETE_TASK_SUCCESSFUL;
        }
        return res;

    }

    /**
     * Done a task by using a search query
     *
     * @param query
     * @param statement
     * @param isUndo
     * @throws CommandExecuteException
     * @throws DataException
     */
    @Override
    public Response done(String query, Statement statement, boolean isUndo)
            throws CommandExecuteException, DataException {

        Response res = new Response(statement.getCommand());

        // search the query by using lucene
        Task[] taskIdList = this.taskData.search(query);
        if (taskIdList == null) {
            throw new CommandExecuteException(
                    CommandExecutionMessage.EXCEPTION_MISSING_TASK);
        }
        /* Check if key exists in taskStateMap */
        if (taskIdList.length > 0) {
            int index;
            // only one result
            if (taskIdList.length == 1) {
                index = 0;
            } else {
                index = this.chooseIndex(taskIdList, NormalMessage.MODIFIED);
            }

            Task task = taskIdList[index];
            if (task.getStatus() == true) {
                logger.debug("The task is already done");
            }
            task.setStatus(true);

            // Update the TaskMap
            this.taskData.updateTaskMap(task.getId(), task, statement, isUndo);

            // Informs user that his add statement is successful
            if (isUndo == false) {
                res.reply = task.getTitle()
                        + NormalMessage.DONE_TASK_SUCCESSFUL;
            }
        } else {
            throw new CommandExecuteException(
                    CommandExecutionMessage.EXCEPTION_MISSING_TASK);
        }
        return res;
    }

    /**
     * Exit the program
     */
    @Override
    public Response exit(Statement statement) {
        Response res = new Response(statement.getCommand());
        res.reply = NormalMessage.EXIT_COMMAND;

        // stop loop
        res.setContinueExecution(false);
        return res;
    }

    /**
     * Display the specified help to user
     *
     * @param command
     */
    @Override
    public Response help(CommandType command, Statement statement) {
        String helpMessage = this.outputHelpMessage(command);
        Response res = new Response(statement.getCommand());
        res.reply = helpMessage;
        return res;
    }

    /**
     * clear a history from the current history list with an index and display
     * it to user
     *
     * @param index
     */
    @Override
    public Response historyClear(int index, Statement statement) {
        // creates an actions that contains the deleted history
        Actions actionsRemoved = this.taskData.deleteHistory(index);
        ArrayList<Actions> temp = new ArrayList<Actions>();
        temp.add(actionsRemoved);

        // display it to user
        Response res = new Response(statement.getCommand());
        res.reply = NormalMessage.HISTORY_CLEAR_SUCCESSFUL;
        res.actions = temp;

        return res;

    }

    /**
     * undo a history from current history list with an index
     *
     * @param index
     * @throws CommandExecuteException
     * @throws DataException
     */
    @Override
    public Response historyUndo(int index, Statement statement)
            throws CommandExecuteException, DataException {
        Response res = new Response(statement.getCommand());
        // undo the history with index
        this.taskData.undoHistory(index, this);

        return res;
    }

    /**
     * Part of CRUD: Update. Modifies the specified Task with new incomplete
     * Task that contains new information Throws [CommandExecutionException]
     * Refer to Issue #50
     *
     * @param query
     * @param incompleteTask
     * @throws CommandExecuteException
     * @throws DataException
     */
    @Override
    public Response modify(String query, Task incompleteTask,
            Statement statement, boolean isUndo)
                    throws CommandExecuteException, DataException {
        Response res = new Response(statement.getCommand());
        // search the task with a query
        Task[] taskIdList = this.taskData.search(query);

        if (taskIdList == null) {
            throw new CommandExecuteException(
                    CommandExecutionMessage.EXCEPTION_MISSING_TASK);
        }
        /* Check if key exists in taskStateMap */
        if (taskIdList.length > 0) {
            int index;
            if (taskIdList.length == 1) {
                index = 0;
            } else {
                index = this.chooseIndex(taskIdList, NormalMessage.MODIFIED);
            }

            logger.debug("Modify: the task exist");

            // retrieve the task from current data
            Task task = taskIdList[index];

            // modify the task
            task.update(incompleteTask);
            logger.debug(new Gson().toJson(task));

            // Update the task data
            this.taskData.updateTaskMap(taskIdList[index].getId(), task,
                    statement, isUndo);
            logger.debug("update task");

            // Informs user that his modify statement is successful
            if (isUndo == false) {
                res.reply = task.getTitle()
                        + NormalMessage.MODIFY_TASK_SUCCESSFUL;
            }
        } else {
            throw new CommandExecuteException(
                    CommandExecutionMessage.EXCEPTION_MISSING_TASK);
        }
        return res;

    }

    @Override
    public void save() {
        // TODO Auto-generated method stub

    }

    @Override
    public Response search(String query, Statement statement)
            throws DataException {
        Response res = new Response(statement.getCommand());
        res.taskList = this.taskData.search(query);
        return res;
    }

    /**
     * display all the tasks to user
     *
     * @throws CommandExecuteException
     */
    @Override
    public Response view(Statement statement) throws CommandExecuteException {

        logger.debug("inside view");
        Response res = new Response(statement.getCommand());
        if (this.taskData.numOfTasks() <= TASK_MAP_MINIMUM_SIZE) {
            /*
             * taskMap size is illegal, most likely cause is that the task map
             * is empty
             */

            res.reply = NormalMessage.NO_TASK_FOUND;
            logger.debug("no task found" + this.taskData.numOfTasks());
            throw new CommandExecuteException(
                    CommandExecutionMessage.EXCEPTION_MISSING_TASK);
        } else {
            try {
                // get the task list from task data
                Task[] taskList = this.taskData.getTaskList();
                logger.debug("Number of Tasks:" + this.taskData.numOfTasks());

                // display the task to user
                Arrays.sort(taskList);

                res.taskList = taskList;

            } catch (Exception e) {
                throw new CommandExecuteException(e.getMessage());
            }
        }
        return res;
    }

    /**
     * display all history to user according to the action's created time
     *
     * @throws CommandExecuteException
     */
    @Override
    public Response viewHistory(Statement statement)
            throws CommandExecuteException {
        Response res = new Response(statement.getCommand());
        if (this.taskData.getActionsList().size() == 0) {
            /*
             * history is empty
             */
            throw new CommandExecuteException(NormalMessage.NO_HISTORY_FOUND);
        } else {
            // display to user
            res.actions = this.taskData.getActionsList();
            return res;

        }

    }

    /**
     * Let the user to choose which task the user wants from search result
     * current return 0 only
     *
     * @param taskIdList
     * @param command
     * @return 0
     */
    private int chooseIndex(Task[] tasks, String command) {

        Arrays.sort(tasks);

        return 0;
    }

    /**
     * @param command
     */
	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\taskmanager\TaskManager.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\terminal\Terminal.java
	 */

public class Terminal {
    private static Terminal instance;
    private static Logger logger = LoggerFactory.getLogger(Terminal.class);
    private Database db;
    private Display display;
    private IParser parser;
    private ITaskManager taskManager;

    private Terminal(TerminalConfig terminalConfig, ITaskManager taskManager,
            Display display, IParser parser, Database db) {
        assert (terminalConfig.isValid());

        this.taskManager = taskManager;
        this.display = display;
        this.parser = parser;
        this.db = db;
    }

    /**
     * Gets the current instance of the Terminal.
     *
     * @return the current instance.
     */
    public static Terminal getInstance() {
        if (instance == null) {
            throw new RuntimeException(
                    "Terminal must be initialized before retrieveing.");
        }

        return instance;
    }

    /**
     * Creates a Task Manager
     *
     * @param db
     * @return return the Task manager.
     */
    public static Terminal initInstance(TerminalConfig config,
            ITaskManager taskManager, Display display, IParser parser,
            Database db) {
        if (instance != null) {
            throw new RuntimeException(
                    "Cannot initialize Terminal as it was initialized before.");
        } else {
            // TO-DO put in config when config is done
            instance = new Terminal(config, taskManager, display, parser, db);
            logger.debug("terminal is initialized");
        }
        return instance;
    }

    /**
     * Take in the terminal object and run it to perform actual actions.
     *
     * @throws Exception
     */
    public void start() throws Exception {

        // Flag that determines whether terminal continues to run or not
        // Default: true
        boolean continueExecution = true;

        String command = null;

        this.display.welcome();
        try (Scanner scanner = new Scanner(this.display.getInputStream())) {
            while (continueExecution) {
                this.display.getInputStream();

                try {
                    command = scanner.nextLine();
                } catch (NullPointerException e) {
                    logger.info(e.getMessage());
                } catch (NoSuchElementException e) {
                    continue;
                }

                // Passes string to Statement.java to parse into a command
                Response res = new Response();
                try {
                    Statement statement = this.parser.parse(command);
                    res = statement.execute(this.taskManager, false);
                    this.display.updateUI(res);
                    this.db.saveToStorage();
                    continueExecution = res.isContinueExecution();
                } catch (DataException | ParseException
                        | CommandExecuteException recoverableException) {
                    res.setException(recoverableException);
                    this.display.updateUI(res);
                } catch (GeneralSecurityException | IOException irrecoverableException) {
                    continueExecution = false;
                    res.setException(irrecoverableException);
                    this.display.updateUI(res);
                } catch (Exception e) {
                    continueExecution = false;
                    res.setException(e);
                    this.display.updateUI(res);
                }

            }
        }
    }
}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\ctrl8\terminal\Terminal.java





	/**
	 * origin: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\run\Start.java
	 */


public class Start {

    // create the command line parser
    private static CommandLineParser commandLineParser = new GnuParser();

    private static Factory factory;

    /**
     * Runs the Task Manager with the file path to extract the data from the
     * file.
     */

    // create the logger
    private static Logger logger = LoggerFactory.getLogger(Start.class);
    // create the Options
    private static Options optionList;
    private static Terminal terminal;

    /**
     * @param args
     *            TODO
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {

        // add all existing Options
        optionList = CommandLineOptions.getOptionList();

        // The terminal that performs all the actions
        String filePath = parseArgs(args);

        factory = Factory.initInstance(filePath);

        Terminal terminal = Terminal.getInstance();
        terminal.start();
    }

    public static void printHelp() {
        printHelp(optionList);
    }

    /**
     * Parses the args of the program. Exit if necessary. When the help option
     * is set, exit the program immediately. If the file option is not set,
     * return the default.
     *
     * @param args
     * @return Database object
     */
    private static String parseArgs(String[] args) {

        try {

            // parse the command line arguments
            CommandLine line = commandLineParser.parse(optionList, args);

            // validate that help has been set
            // exit if -h is used
            if (line.hasOption(CommandLineOptions.HELP.toString())) {
                printHelp(optionList);
                System.exit(1);
                return null;
            }

            // validate that file's Path has been set
            if (line.hasOption("filePath")) {
                String filePath = line.getOptionValue("filePath");

                // print the value of filePath
                logger.info("Database file is at:" + filePath);

                return filePath;
            } else {
                return null;
            }

        } catch (org.apache.commons.cli.ParseException e) {
            logger.info(ErrorMessage.OPTION_NOT_FOUND);
            printHelp(optionList);
            System.exit(1);
            return null;
        }

    }

    // print the help message
    private static void printHelp(Options optionList) {
        HelpFormatter formatter = new HelpFormatter();
        formatter
        .printHelp(
                "Ctrl-8",
                "Welcome to Ctrl-8. Below are the options you can choose",
                optionList,
                "For more information please refer to https://github.com/cs2103jan2015-w09-4j/main",
                true);
    }

}

	// End of segment: C:\Users\imchenchen\Documents\GitHub\cs2103jan2015-w09-4j\main\src\main\java\w094j\run\Start.java





